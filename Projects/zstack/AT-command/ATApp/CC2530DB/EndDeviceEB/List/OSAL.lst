###############################################################################
#
# IAR C/C++ Compiler V10.30.1.6000 for 8051               23/Feb/2022  09:35:01
# Copyright 2004-2018 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        D:\A_proj\A_Cproj\Zigbee\ZigBee-DoorLock-2021.09.27\Components\osal\common\OSAL.c
#    Command line       =  
#        -f C:\Users\Administrator\AppData\Local\Temp\EW3E87.tmp
#        (D:\A_proj\A_Cproj\Zigbee\ZigBee-DoorLock-2021.09.27\Components\osal\common\OSAL.c
#        -D WDT_IN_PM1 -D ZIGBEEPRO -D INTER_PAN -D ZIGBEE_FREQ_AGILITY -D
#        DISABLE_GREENPOWER_BASIC_PROXY -D REFLECTOR -D HAL_UART=FALSE -D
#        HAL_LED=FALSE -D HAL_KEY=FALSE -D SECURE=1 -D TC_LINKKEY_JOIN -D
#        NV_INIT -D NV_RESTORE -D POWER_SAVING -D NWK_AUTO_POLL -D xZTOOL_P1 -D
#        xMT_TASK -D xMT_APP_FUNC -D xMT_SYS_FUNC -D xMT_ZDO_FUNC -D
#        xMT_ZDO_MGMT -D xMT_APP_CNF_FUNC -D xLEGACY_LCD_DEBUG -D
#        xLCD_SUPPORTED=DEBUG -D MULTICAST_ENABLED=FALSE -D ZCL_READ -D
#        ZCL_WRITE -D ZCL_DISCOVER -D ZCL_BASIC -D ZCL_IDENTIFY -D ZCL_SCENES
#        -D ZCL_GROUPS -D BDB_REPORTING -D ZCL_DOORLOCK -D ZCL_DOORLOCK_EXT -D
#        ISR_KEYINTERRUPT -lC
#        D:\A_proj\A_Cproj\Zigbee\ZigBee-DoorLock-2021.09.27\Projects\zstack\AT-command\ATApp\CC2530DB\EndDeviceEB\List
#        -lA
#        D:\A_proj\A_Cproj\Zigbee\ZigBee-DoorLock-2021.09.27\Projects\zstack\AT-command\ATApp\CC2530DB\EndDeviceEB\List
#        --diag_suppress Pe001,Pa010 -o
#        D:\A_proj\A_Cproj\Zigbee\ZigBee-DoorLock-2021.09.27\Projects\zstack\AT-command\ATApp\CC2530DB\EndDeviceEB\Obj
#        -e --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data_rom --nr_virtual_regs 16 -f
#        D:\A_proj\A_Cproj\Zigbee\ZigBee-DoorLock-2021.09.27\Projects\zstack\AT-command\ATApp\CC2530DB\..\..\..\Tools\CC2530DB\f8wEndev.cfg
#        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_TX_DATA_MAX=3
#        -DMAC_CFG_TX_MAX=6 -DMAC_CFG_RX_MAX=3) -f
#        D:\A_proj\A_Cproj\Zigbee\ZigBee-DoorLock-2021.09.27\Projects\zstack\AT-command\ATApp\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg
#        (-DZIGBEEPRO -DSECURE=1 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0xFFFF
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=10 -DMAX_RTG_ENTRIES=15 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 -DDEFAULT_KEY={0} -DMAC_MAX_FRAME_SIZE=116
#        -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const __code"
#        -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=300
#        -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100 -DREJOIN_POLL_RATE=440
#        -DREJOIN_BACKOFF=900000 -DREJOIN_SCAN=900000) -f
#        D:\A_proj\A_Cproj\Zigbee\ZigBee-DoorLock-2021.09.27\Projects\zstack\AT-command\ATApp\CC2530DB\..\..\..\Tools\CC2530DB\f8wZCL.cfg
#        -I
#        D:\A_proj\A_Cproj\Zigbee\ZigBee-DoorLock-2021.09.27\Projects\zstack\AT-command\ATApp\CC2530DB\
#        -I
#        D:\A_proj\A_Cproj\Zigbee\ZigBee-DoorLock-2021.09.27\Projects\zstack\AT-command\ATApp\CC2530DB\..\Source\
#        -I
#        D:\A_proj\A_Cproj\Zigbee\ZigBee-DoorLock-2021.09.27\Projects\zstack\AT-command\ATApp\CC2530DB\..\Source\ZCL\
#        -I
#        D:\A_proj\A_Cproj\Zigbee\ZigBee-DoorLock-2021.09.27\Projects\zstack\AT-command\ATApp\CC2530DB\..\Source\UserAPI\
#        -I
#        D:\A_proj\A_Cproj\Zigbee\ZigBee-DoorLock-2021.09.27\Projects\zstack\AT-command\ATApp\CC2530DB\..\Source\Controller\
#        -I
#        D:\A_proj\A_Cproj\Zigbee\ZigBee-DoorLock-2021.09.27\Projects\zstack\AT-command\ATApp\CC2530DB\..\..\..\ZMain\TI2530DB\
#        -I
#        D:\A_proj\A_Cproj\Zigbee\ZigBee-DoorLock-2021.09.27\Projects\zstack\AT-command\ATApp\CC2530DB\..\..\..\..\..\Components\hal\include\
#        -I
#        D:\A_proj\A_Cproj\Zigbee\ZigBee-DoorLock-2021.09.27\Projects\zstack\AT-command\ATApp\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\
#        -I
#        D:\A_proj\A_Cproj\Zigbee\ZigBee-DoorLock-2021.09.27\Projects\zstack\AT-command\ATApp\CC2530DB\..\..\..\..\..\Components\mac\include\
#        -I
#        D:\A_proj\A_Cproj\Zigbee\ZigBee-DoorLock-2021.09.27\Projects\zstack\AT-command\ATApp\CC2530DB\..\..\..\..\..\Components\mac\high_level\
#        -I
#        D:\A_proj\A_Cproj\Zigbee\ZigBee-DoorLock-2021.09.27\Projects\zstack\AT-command\ATApp\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\
#        -I
#        D:\A_proj\A_Cproj\Zigbee\ZigBee-DoorLock-2021.09.27\Projects\zstack\AT-command\ATApp\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\single_chip\
#        -I
#        D:\A_proj\A_Cproj\Zigbee\ZigBee-DoorLock-2021.09.27\Projects\zstack\AT-command\ATApp\CC2530DB\..\..\..\..\..\Components\mt\
#        -I
#        D:\A_proj\A_Cproj\Zigbee\ZigBee-DoorLock-2021.09.27\Projects\zstack\AT-command\ATApp\CC2530DB\..\..\..\..\..\Components\osal\include\
#        -I
#        D:\A_proj\A_Cproj\Zigbee\ZigBee-DoorLock-2021.09.27\Projects\zstack\AT-command\ATApp\CC2530DB\..\..\..\..\..\Components\services\saddr\
#        -I
#        D:\A_proj\A_Cproj\Zigbee\ZigBee-DoorLock-2021.09.27\Projects\zstack\AT-command\ATApp\CC2530DB\..\..\..\..\..\Components\services\sdata\
#        -I
#        D:\A_proj\A_Cproj\Zigbee\ZigBee-DoorLock-2021.09.27\Projects\zstack\AT-command\ATApp\CC2530DB\..\..\..\..\..\Components\stack\af\
#        -I
#        D:\A_proj\A_Cproj\Zigbee\ZigBee-DoorLock-2021.09.27\Projects\zstack\AT-command\ATApp\CC2530DB\..\..\..\..\..\Components\stack\bdb\
#        -I
#        D:\A_proj\A_Cproj\Zigbee\ZigBee-DoorLock-2021.09.27\Projects\zstack\AT-command\ATApp\CC2530DB\..\..\..\..\..\Components\stack\gp\
#        -I
#        D:\A_proj\A_Cproj\Zigbee\ZigBee-DoorLock-2021.09.27\Projects\zstack\AT-command\ATApp\CC2530DB\..\..\..\..\..\Components\stack\nwk\
#        -I
#        D:\A_proj\A_Cproj\Zigbee\ZigBee-DoorLock-2021.09.27\Projects\zstack\AT-command\ATApp\CC2530DB\..\..\..\..\..\Components\stack\sapi\
#        -I
#        D:\A_proj\A_Cproj\Zigbee\ZigBee-DoorLock-2021.09.27\Projects\zstack\AT-command\ATApp\CC2530DB\..\..\..\..\..\Components\stack\sec\
#        -I
#        D:\A_proj\A_Cproj\Zigbee\ZigBee-DoorLock-2021.09.27\Projects\zstack\AT-command\ATApp\CC2530DB\..\..\..\..\..\Components\stack\sys\
#        -I
#        D:\A_proj\A_Cproj\Zigbee\ZigBee-DoorLock-2021.09.27\Projects\zstack\AT-command\ATApp\CC2530DB\..\..\..\..\..\Components\stack\zcl\
#        -I
#        D:\A_proj\A_Cproj\Zigbee\ZigBee-DoorLock-2021.09.27\Projects\zstack\AT-command\ATApp\CC2530DB\..\..\..\..\..\Components\stack\zdo\
#        -I
#        D:\A_proj\A_Cproj\Zigbee\ZigBee-DoorLock-2021.09.27\Projects\zstack\AT-command\ATApp\CC2530DB\..\..\..\..\..\Components\zmac\
#        -I
#        D:\A_proj\A_Cproj\Zigbee\ZigBee-DoorLock-2021.09.27\Projects\zstack\AT-command\ATApp\CC2530DB\..\..\..\..\..\Components\zmac\f8w\
#        -Ohz --require_prototypes)
#    Locale             =  Chinese (Simplified)_CHN.936
#    List file          =  
#        D:\A_proj\A_Cproj\Zigbee\ZigBee-DoorLock-2021.09.27\Projects\zstack\AT-command\ATApp\CC2530DB\EndDeviceEB\List\OSAL.lst
#    Object file        =  
#        D:\A_proj\A_Cproj\Zigbee\ZigBee-DoorLock-2021.09.27\Projects\zstack\AT-command\ATApp\CC2530DB\EndDeviceEB\Obj\OSAL.r51
#
###############################################################################

D:\A_proj\A_Cproj\Zigbee\ZigBee-DoorLock-2021.09.27\Components\osal\common\OSAL.c
      1          /**************************************************************************************************
      2            Filename:       OSAL.c
      3            Revised:        $Date: 2014-11-04 15:36:27 -0800 (Tue, 04 Nov 2014) $
      4            Revision:       $Revision: 40989 $
      5          
      6            Description:    This API allows the software components in the Z-stack to be written
      7                            independently of the specifics of the operating system, kernel or tasking
      8                            environment (including control loops or connect-to-interrupt systems).
      9          
     10          
     11            Copyright 2004-2014 Texas Instruments Incorporated. All rights reserved.
     12          
     13            IMPORTANT: Your use of this Software is limited to those specific rights
     14            granted under the terms of a software license agreement between the user
     15            who downloaded the software, his/her employer (which must be your employer)
     16            and Texas Instruments Incorporated (the "License"). You may not use this
     17            Software unless you agree to abide by the terms of the License. The License
     18            limits your use, and you acknowledge, that the Software may not be modified,
     19            copied or distributed unless embedded on a Texas Instruments microcontroller
     20            or used solely and exclusively in conjunction with a Texas Instruments radio
     21            frequency transceiver, which is integrated into your product. Other than for
     22            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     23            works of, modify, distribute, perform, display or sell this Software and/or
     24            its documentation for any purpose.
     25          
     26            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     27            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     28            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     29            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     30            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     31            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     32            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     33            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     34            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     35            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     36            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     37          
     38            Should you have any questions regarding your right to use this Software,
     39            contact Texas Instruments Incorporated at www.TI.com.
     40          **************************************************************************************************/
     41          
     42          /*********************************************************************
     43           * INCLUDES
     44           */
     45          
     46          #include <string.h>
     47          
     48          #include "comdef.h"
     49          #include "hal_board.h"

   \                                 In  segment SFR_AN, at 0xa8
   \   union <unnamed> volatile __sfr _A_IEN0
   \                     _A_IEN0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc9
   \   unsigned char volatile __sfr WDCTL
   \                     WDCTL:
   \   000000                DS 1
     50          #include "OSAL.h"
     51          #include "OSAL_Tasks.h"
     52          #include "OSAL_Memory.h"
     53          #include "OSAL_PwrMgr.h"
     54          #include "OSAL_Clock.h"
     55          
     56          #include "OnBoard.h"
     57          
     58          /* HAL */
     59          #include "hal_drivers.h"
     60          
     61          #ifdef IAR_ARMCM3_LM
     62            #include "FreeRTOSConfig.h"
     63            #include "osal_task.h"
     64          #endif
     65          
     66          #ifdef USE_ICALL
     67            #include <ICall.h>
     68          #endif /* USE_ICALL */
     69          
     70          #include "AT_doorlock.h"
     71          
     72          /*********************************************************************
     73           * MACROS
     74           */
     75          
     76          /*********************************************************************
     77           * CONSTANTS
     78           */
     79          #ifdef USE_ICALL
     80          // A bit mask to use to indicate a proxy OSAL task ID.
     81          #define OSAL_PROXY_ID_FLAG       0x80
     82          #endif // USE_ICALL
     83          
     84          /*********************************************************************
     85           * TYPEDEFS
     86           */
     87          
     88          /*********************************************************************
     89           * GLOBAL VARIABLES
     90           */
     91          
     92          // Message Pool Definitions

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     93          osal_msg_q_t osal_qHead;
   \                     osal_qHead:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
     94          
     95          #ifdef USE_ICALL
     96          // OSAL event loop hook function pointer 
     97          void (*osal_eventloop_hook)(void) = NULL;
     98          #endif /* USE_ICALL */
     99          
    100          /*********************************************************************
    101           * EXTERNAL VARIABLES
    102           */
    103          
    104          /*********************************************************************
    105           * EXTERNAL FUNCTIONS
    106           */
    107          
    108          /*********************************************************************
    109           * LOCAL VARIABLES
    110           */
    111          
    112          // Index of active task

   \                                 In  segment XDATA_I, align 1, keep-with-next
    113          static uint8 activeTaskID = TASK_NO_TASK;
   \                     activeTaskID:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for activeTaskID>`
   \   000001                REQUIRE __INIT_XDATA_I
    114          
    115          #ifdef USE_ICALL
    116          // Maximum number of proxy tasks
    117          #ifndef OSAL_MAX_NUM_PROXY_TASKS
    118          #define OSAL_MAX_NUM_PROXY_TASKS 2
    119          #endif // OSAL_MAX_NUM_PROXY_TASKS
    120          
    121          // ICall entity ID value used to indicate invalid value
    122          #define OSAL_INVALID_DISPATCH_ID 0xffu
    123          
    124          // Semaphore associated with OSAL RTOS thread receive queue
    125          ICall_Semaphore osal_semaphore;
    126          
    127          // Entity ID that OSAL RTOS thread has registered with
    128          ICall_EntityID osal_entity;
    129          
    130          // Last read tick count value reflected into the OSAL timer
    131          uint_least32_t osal_last_timestamp;
    132          
    133          // RTOS tick period in microseconds
    134          uint_least32_t osal_tickperiod;
    135          
    136          // Maximum timeout value in milliseconds that can be used with an RTOS timer
    137          uint_least32_t osal_max_msecs;
    138          
    139          // Timer ID for RTOS timer as backend engine for OSAL timer
    140          static ICall_TimerID osal_timerid_msec_timer;
    141          
    142          // Timer callback sequence tracking counter to handle race condition
    143          static unsigned osal_msec_timer_seq = 0;
    144          
    145          // proxy task ID map
    146          static uint8 osal_proxy_tasks[OSAL_MAX_NUM_PROXY_TASKS];
    147          
    148          // service dispatcher entity IDs corresponding to OSAL tasks
    149          static uint8 *osal_dispatch_entities;
    150          
    151          static uint8 osal_notask_entity;
    152          
    153          #endif // USE_ICALL
    154          
    155          /*********************************************************************
    156           * LOCAL FUNCTION PROTOTYPES
    157           */
    158          
    159          static uint8 osal_msg_enqueue_push( uint8 destination_task, uint8 *msg_ptr, uint8 urgent );
    160          
    161          #ifdef USE_ICALL
    162          static uint8 osal_alien2proxy(ICall_EntityID entity);
    163          static ICall_EntityID osal_proxy2alien(uint8 proxyid);
    164          static uint8 osal_dispatch2id(ICall_EntityID entity);
    165          static void osal_msec_timer_cback(void *arg);
    166          #endif // USE_ICALL
    167          
    168          /*********************************************************************
    169           * HELPER FUNCTIONS
    170           */
    171          /* very ugly stub so Keil can compile */
    172          #ifdef __KEIL__
    173          char *  itoa ( int value, char * buffer, int radix )
    174          {
    175            return(buffer);
    176          }
    177          #endif
    178          
    179          /*********************************************************************
    180           * @fn      osal_strlen
    181           *
    182           * @brief
    183           *
    184           *   Calculates the length of a string.  The string must be null
    185           *   terminated.
    186           *
    187           * @param   char *pString - pointer to text string
    188           *
    189           * @return  int - number of characters
    190           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    191          int osal_strlen( char *pString )
   \                     osal_strlen:
    192          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    193            return (int)( strlen( pString ) );
   \   000004                ; Setup parameters for call to function strlen
   \   000004   12....       LCALL     `??strlen::?relay`; Banked call to: strlen
   \   000007   02....       LJMP      ?Subroutine0 & 0xFFFF
    194          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   D083         POP       DPH
   \   000002   D082         POP       DPL
   \   000004   02....       LJMP      ?BRET
    195          
    196          /*********************************************************************
    197           * @fn      osal_memcpy
    198           *
    199           * @brief
    200           *
    201           *   Generic memory copy.
    202           *
    203           *   Note: This function differs from the standard memcpy(), since
    204           *         it returns the pointer to the next destination uint8. The
    205           *         standard memcpy() returns the original destination address.
    206           *
    207           * @param   dst - destination address
    208           * @param   src - source address
    209           * @param   len - number of bytes to copy
    210           *
    211           * @return  pointer to end of destination buffer
    212           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    213          void *osal_memcpy( void *dst, const void GENERIC *src, unsigned int len )
   \                     osal_memcpy:
    214          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   FF           MOV       R7,A
    215            uint8 *pDst;
    216            const uint8 GENERIC *pSrc;
    217          
    218            pSrc = src;
   \   000009   7409         MOV       A,#0x9
   \   00000B   12....       LCALL     ?XSTACK_DISP0_8
   \   00000E   12....       LCALL     ?Subroutine13 & 0xFFFF
    219            pDst = dst;
   \                     ??CrossCallReturnLabel_63:
   \   000011   8E82         MOV       DPL,R6
   \   000013   8F83         MOV       DPH,R7
   \   000015   800C         SJMP      ??osal_memcpy_0
    220          
    221            while ( len-- )
    222              *pDst++ = *pSrc++;
   \                     ??osal_memcpy_1:
   \   000017   12....       LCALL     ?C_GPTR_LOAD
   \   00001A   F0           MOVX      @DPTR,A
   \   00001B   E9           MOV       A,R1
   \   00001C   2401         ADD       A,#0x1
   \   00001E   09           INC       R1
   \   00001F   E4           CLR       A
   \   000020   3A           ADDC      A,R2
   \   000021   FA           MOV       R2,A
   \   000022   A3           INC       DPTR
   \                     ??osal_memcpy_0:
   \   000023   12....       LCALL     ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_26:
   \   000026   70EF         JNZ       ??osal_memcpy_1
    223          
    224            return ( pDst );
   \   000028   02....       LJMP      ?Subroutine1 & 0xFFFF
    225          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine21:
   \   000000   EC           MOV       A,R4
   \   000001   FE           MOV       R6,A
   \   000002   ED           MOV       A,R5
   \   000003   FF           MOV       R7,A
   \   000004   EE           MOV       A,R6
   \   000005   24FF         ADD       A,#-0x1
   \   000007   1C           DEC       R4
   \   000008   EF           MOV       A,R7
   \   000009   34FF         ADDC      A,#-0x1
   \   00000B   FD           MOV       R5,A
   \   00000C   EE           MOV       A,R6
   \   00000D   4F           ORL       A,R7
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   AA82         MOV       R2,DPL
   \   000002   AB83         MOV       R3,DPH
   \   000004                REQUIRE ??Subroutine27_0
   \   000004                ; // Fall through to label ??Subroutine27_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine27_0:
   \   000000   7F01         MOV       R7,#0x1
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine13:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F9           MOV       R1,A
   \   000002   A3           INC       DPTR
   \   000003                REQUIRE ??Subroutine32_0
   \   000003                ; // Fall through to label ??Subroutine32_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine32_0:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   FA           MOV       R2,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   FB           MOV       R3,A
   \   000005   22           RET
    226          
    227          /*********************************************************************
    228           * @fn      osal_revmemcpy
    229           *
    230           * @brief   Generic reverse memory copy.  Starts at the end of the
    231           *   source buffer, by taking the source address pointer and moving
    232           *   pointer ahead "len" bytes, then decrementing the pointer.
    233           *
    234           *   Note: This function differs from the standard memcpy(), since
    235           *         it returns the pointer to the next destination uint8. The
    236           *         standard memcpy() returns the original destination address.
    237           *
    238           * @param   dst - destination address
    239           * @param   src - source address
    240           * @param   len - number of bytes to copy
    241           *
    242           * @return  pointer to end of destination buffer
    243           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    244          void *osal_revmemcpy( void *dst, const void GENERIC *src, unsigned int len )
   \                     osal_revmemcpy:
    245          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   FF           MOV       R7,A
    246            uint8 *pDst;
    247            const uint8 GENERIC *pSrc;
    248          
    249            pSrc = src;
    250            pSrc += (len-1);
   \   000009   7409         MOV       A,#0x9
   \   00000B   12....       LCALL     ?XSTACK_DISP0_8
   \   00000E   12....       LCALL     ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_64:
   \   000011   E9           MOV       A,R1
   \   000012   2C           ADD       A,R4
   \   000013   F9           MOV       R1,A
   \   000014   EA           MOV       A,R2
   \   000015   3D           ADDC      A,R5
   \   000016   FA           MOV       R2,A
   \   000017   E9           MOV       A,R1
   \   000018   24FF         ADD       A,#-0x1
   \   00001A   19           DEC       R1
   \   00001B   EA           MOV       A,R2
   \   00001C   34FF         ADDC      A,#-0x1
   \   00001E   FA           MOV       R2,A
    251            pDst = dst;
   \   00001F   8E82         MOV       DPL,R6
   \   000021   8F83         MOV       DPH,R7
   \   000023   800D         SJMP      ??osal_revmemcpy_0
    252          
    253            while ( len-- )
    254              *pDst++ = *pSrc--;
   \                     ??osal_revmemcpy_1:
   \   000025   12....       LCALL     ?C_GPTR_LOAD
   \   000028   F0           MOVX      @DPTR,A
   \   000029   E9           MOV       A,R1
   \   00002A   24FF         ADD       A,#-0x1
   \   00002C   19           DEC       R1
   \   00002D   EA           MOV       A,R2
   \   00002E   34FF         ADDC      A,#-0x1
   \   000030   FA           MOV       R2,A
   \   000031   A3           INC       DPTR
   \                     ??osal_revmemcpy_0:
   \   000032   12....       LCALL     ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_27:
   \   000035   70EE         JNZ       ??osal_revmemcpy_1
    255          
    256            return ( pDst );
   \   000037   02....       LJMP      ?Subroutine1 & 0xFFFF
    257          }
    258          
    259          /*********************************************************************
    260           * @fn      osal_memdup
    261           *
    262           * @brief   Allocates a buffer [with osal_mem_alloc()] and copies
    263           *          the src buffer into the newly allocated space.
    264           *
    265           * @param   src - source address
    266           * @param   len - number of bytes to copy
    267           *
    268           * @return  pointer to the new allocated buffer, or NULL if
    269           *          allocation problem.
    270           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    271          void *osal_memdup( const void GENERIC *src, unsigned int len )
   \                     osal_memdup:
    272          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000   74F1         MOV       A,#-0xf
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 0
   \   000005   89..         MOV       ?V4,R1
   \   000007   8A..         MOV       ?V5,R2
   \   000009   8B..         MOV       ?V6,R3
   \   00000B   EC           MOV       A,R4
   \   00000C   FE           MOV       R6,A
   \   00000D   ED           MOV       A,R5
   \   00000E   FF           MOV       R7,A
    273            uint8 *pDst;
    274          
    275            pDst = osal_mem_alloc( len );
   \   00000F                ; Setup parameters for call to function osal_mem_alloc
   \   00000F   EC           MOV       A,R4
   \   000010   FA           MOV       R2,A
   \   000011   ED           MOV       A,R5
   \   000012   FB           MOV       R3,A
   \   000013   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000016   8A..         MOV       ?V0,R2
   \   000018   8B..         MOV       ?V1,R3
    276            if ( pDst )
   \   00001A   EA           MOV       A,R2
   \   00001B   4B           ORL       A,R3
   \   00001C   6011         JZ        ??osal_memdup_0
    277            {
    278              VOID osal_memcpy( pDst, src, len );
   \   00001E                ; Setup parameters for call to function osal_memcpy
   \   00001E   78..         MOV       R0,#?V4
   \   000020   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   000023   EE           MOV       A,R6
   \   000024   FC           MOV       R4,A
   \   000025   EF           MOV       A,R7
   \   000026   FD           MOV       R5,A
   \   000027   12....       LCALL     `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   00002A   7403         MOV       A,#0x3
   \   00002C   12....       LCALL     ?DEALLOC_XSTACK8
    279            }
    280          
    281            return ( (void *)pDst );
   \                     ??osal_memdup_0:
   \   00002F   AA..         MOV       R2,?V0
   \   000031   AB..         MOV       R3,?V1
   \   000033   7F07         MOV       R7,#0x7
   \   000035   02....       LJMP      ?BANKED_LEAVE_XDATA
    282          }
    283          
    284          /*********************************************************************
    285           * @fn      osal_memcmp
    286           *
    287           * @brief
    288           *
    289           *   Generic memory compare.
    290           *
    291           * @param   src1 - source 1 addrexx
    292           * @param   src2 - source 2 address
    293           * @param   len - number of bytes to compare
    294           *
    295           * @return  TRUE - same, FALSE - different
    296           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    297          uint8 osal_memcmp( const void GENERIC *src1, const void GENERIC *src2, unsigned int len )
   \                     osal_memcmp:
    298          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000   74ED         MOV       A,#-0x13
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 19
   \   000005                ; Auto size: 0
    299            const uint8 GENERIC *pSrc1;
    300            const uint8 GENERIC *pSrc2;
    301          
    302            pSrc1 = src1;
   \   000005   89..         MOV       ?V0,R1
   \   000007   8A..         MOV       ?V1,R2
   \   000009   8B..         MOV       ?V2,R3
    303            pSrc2 = src2;
   \   00000B   7413         MOV       A,#0x13
   \   00000D   12....       LCALL     ?XSTACK_DISP0_8
   \   000010   E0           MOVX      A,@DPTR
   \   000011   F5..         MOV       ?V4,A
   \   000013   A3           INC       DPTR
   \   000014   E0           MOVX      A,@DPTR
   \   000015   F5..         MOV       ?V5,A
   \   000017   A3           INC       DPTR
   \   000018   E0           MOVX      A,@DPTR
   \   000019   F5..         MOV       ?V6,A
    304          
    305            while ( len-- )
   \                     ??osal_memcmp_0:
   \   00001B   EC           MOV       A,R4
   \   00001C   F8           MOV       R0,A
   \   00001D   ED           MOV       A,R5
   \   00001E   F9           MOV       R1,A
   \   00001F   E8           MOV       A,R0
   \   000020   24FF         ADD       A,#-0x1
   \   000022   1C           DEC       R4
   \   000023   E9           MOV       A,R1
   \   000024   34FF         ADDC      A,#-0x1
   \   000026   FD           MOV       R5,A
   \   000027   E8           MOV       A,R0
   \   000028   49           ORL       A,R1
   \   000029   6037         JZ        ??osal_memcmp_1
    306            {
    307              if( *pSrc1++ != *pSrc2++ )
   \   00002B   A9..         MOV       R1,?V0
   \   00002D   AA..         MOV       R2,?V1
   \   00002F   AB..         MOV       R3,?V2
   \   000031   E9           MOV       A,R1
   \   000032   2401         ADD       A,#0x1
   \   000034   F5..         MOV       ?V0,A
   \   000036   E4           CLR       A
   \   000037   3A           ADDC      A,R2
   \   000038   F5..         MOV       ?V1,A
   \   00003A   85....       MOV       ?V8,?V4
   \   00003D   85....       MOV       ?V9,?V5
   \   000040   85....       MOV       ?V10,?V6
   \   000043   E5..         MOV       A,?V4
   \   000045   2401         ADD       A,#0x1
   \   000047   F5..         MOV       ?V4,A
   \   000049   E4           CLR       A
   \   00004A   35..         ADDC      A,?V5
   \   00004C   F5..         MOV       ?V5,A
   \   00004E   12....       LCALL     ?C_GPTR_LOAD
   \   000051   F8           MOV       R0,A
   \   000052   A9..         MOV       R1,?V8
   \   000054   AA..         MOV       R2,?V9
   \   000056   AB..         MOV       R3,?V10
   \   000058   12....       LCALL     ?C_GPTR_LOAD
   \   00005B   68           XRL       A,R0
   \   00005C   60BD         JZ        ??osal_memcmp_0
    308                return FALSE;
   \   00005E   7900         MOV       R1,#0x0
   \   000060   8002         SJMP      ??osal_memcmp_2
    309            }
    310            return TRUE;
   \                     ??osal_memcmp_1:
   \   000062   7901         MOV       R1,#0x1
   \                     ??osal_memcmp_2:
   \   000064   7F0B         MOV       R7,#0xb
   \   000066   02....       LJMP      ?BANKED_LEAVE_XDATA
    311          }
    312          
    313          
    314          /*********************************************************************
    315           * @fn      osal_memset
    316           *
    317           * @brief
    318           *
    319           *   Set memory buffer to value.
    320           *
    321           * @param   dest - pointer to buffer
    322           * @param   value - what to set each uint8 of the message
    323           * @param   size - how big
    324           *
    325           * @return  pointer to destination buffer
    326           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    327          void *osal_memset( void *dest, uint8 value, int len )
   \                     osal_memset:
    328          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
    329            return memset( dest, value, len );
   \   000005                ; Setup parameters for call to function memset
   \   000005   8C..         MOV       ?V0,R4
   \   000007   8D..         MOV       ?V1,R5
   \   000009   78..         MOV       R0,#?V0
   \   00000B   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00000E   E9           MOV       A,R1
   \   00000F   FC           MOV       R4,A
   \   000010   7D00         MOV       R5,#0x0
   \   000012   12....       LCALL     `??memset::?relay`; Banked call to: memset
   \   000015   7402         MOV       A,#0x2
   \   000017   12....       LCALL     ?DEALLOC_XSTACK8
   \   00001A   02....       LJMP      ?Subroutine2 & 0xFFFF
    330          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   7F02         MOV       R7,#0x2
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA
    331          
    332          /*********************************************************************
    333           * @fn      osal_build_uint16
    334           *
    335           * @brief
    336           *
    337           *   Build a uint16 out of 2 bytes (0 then 1).
    338           *
    339           * @param   swapped - 0 then 1
    340           *
    341           * @return  uint16
    342           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    343          uint16 osal_build_uint16( uint8 *swapped )
   \                     osal_build_uint16:
    344          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    345            return ( BUILD_UINT16( swapped[0], swapped[1] ) );
   \   000004   8A82         MOV       DPL,R2
   \   000006   8B83         MOV       DPH,R3
   \   000008   E0           MOVX      A,@DPTR
   \   000009   FC           MOV       R4,A
   \   00000A   A3           INC       DPTR
   \   00000B   E0           MOVX      A,@DPTR
   \   00000C   F8           MOV       R0,A
   \   00000D   E4           CLR       A
   \   00000E   C8           XCH       A,R0
   \   00000F   F9           MOV       R1,A
   \   000010   EC           MOV       A,R4
   \   000011   28           ADD       A,R0
   \   000012   FA           MOV       R2,A
   \   000013   E4           CLR       A
   \   000014   39           ADDC      A,R1
   \   000015   FB           MOV       R3,A
   \   000016   02....       LJMP      ?Subroutine0 & 0xFFFF
    346          }
    347          
    348          /*********************************************************************
    349           * @fn      osal_build_uint32
    350           *
    351           * @brief
    352           *
    353           *   Build a uint32 out of sequential bytes.
    354           *
    355           * @param   swapped - sequential bytes
    356           * @param   len - number of bytes in the uint8 array
    357           *
    358           * @return  uint32
    359           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    360          uint32 osal_build_uint32( uint8 *swapped, uint8 len )
   \                     osal_build_uint32:
    361          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV       A,#-0x10
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   E9           MOV       A,R1
   \   000006   FE           MOV       R6,A
    362            if ( len == 2 )
   \   000007   8A82         MOV       DPL,R2
   \   000009   8B83         MOV       DPH,R3
   \   00000B   E0           MOVX      A,@DPTR
   \   00000C   F5..         MOV       ?V4,A
   \   00000E   E4           CLR       A
   \   00000F   F5..         MOV       ?V5,A
   \   000011   F5..         MOV       ?V6,A
   \   000013   F5..         MOV       ?V7,A
   \   000015   7402         MOV       A,#0x2
   \   000017   6E           XRL       A,R6
   \   000018   7005         JNZ       ??osal_build_uint32_0
    363              return ( BUILD_UINT32( swapped[0], swapped[1], 0L, 0L ) );
   \   00001A   12....       LCALL     ?Subroutine24 & 0xFFFF
   \                     ??CrossCallReturnLabel_33:
   \   00001D   8047         SJMP      ??osal_build_uint32_1
    364            else if ( len == 3 )
   \                     ??osal_build_uint32_0:
   \   00001F   7403         MOV       A,#0x3
   \   000021   6E           XRL       A,R6
   \   000022   7012         JNZ       ??osal_build_uint32_2
    365              return ( BUILD_UINT32( swapped[0], swapped[1], swapped[2], 0L ) );
   \   000024   12....       LCALL     ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_9:
   \   000027   12....       LCALL     ?L_SHL
   \   00002A   78..         MOV       R0,#?V4
   \   00002C   79..         MOV       R1,#?V0
   \   00002E   12....       LCALL     ?L_ADD
   \   000031   12....       LCALL     ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_20:
   \   000034   8030         SJMP      ??osal_build_uint32_1
    366            else if ( len == 4 )
   \                     ??osal_build_uint32_2:
   \   000036   7404         MOV       A,#0x4
   \   000038   6E           XRL       A,R6
   \   000039   7037         JNZ       ??osal_build_uint32_3
    367              return ( BUILD_UINT32( swapped[0], swapped[1], swapped[2], swapped[3] ) );
   \   00003B   12....       LCALL     ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_10:
   \   00003E   12....       LCALL     ?L_SHL
   \   000041   78..         MOV       R0,#?V4
   \   000043   79..         MOV       R1,#?V0
   \   000045   12....       LCALL     ?L_ADD
   \   000048   12....       LCALL     ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_21:
   \   00004B   78..         MOV       R0,#?V0
   \   00004D   12....       LCALL     ?L_SHL
   \   000050   78..         MOV       R0,#?V4
   \   000052   79..         MOV       R1,#?V0
   \   000054   12....       LCALL     ?L_ADD
   \   000057   8A82         MOV       DPL,R2
   \   000059   8B83         MOV       DPH,R3
   \   00005B   A3           INC       DPTR
   \   00005C   A3           INC       DPTR
   \   00005D   A3           INC       DPTR
   \   00005E   E0           MOVX      A,@DPTR
   \   00005F   F5..         MOV       ?V0,A
   \   000061   E4           CLR       A
   \   000062   F5..         MOV       ?V2,A
   \   000064   7418         MOV       A,#0x18
   \                     ??osal_build_uint32_1:
   \   000066   78..         MOV       R0,#?V0
   \   000068   12....       LCALL     ?L_SHL
   \   00006B   78..         MOV       R0,#?V4
   \   00006D   79..         MOV       R1,#?V0
   \   00006F   12....       LCALL     ?L_ADD
    368            else
    369              return ( (uint32)swapped[0] );
   \                     ??osal_build_uint32_3:
   \   000072   AA..         MOV       R2,?V4
   \   000074   AB..         MOV       R3,?V5
   \   000076   AC..         MOV       R4,?V6
   \   000078   AD..         MOV       R5,?V7
   \   00007A                REQUIRE ?Subroutine3
   \   00007A                ; // Fall through to label ?Subroutine3
    370          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   7F08         MOV       R7,#0x8
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine16:
   \   000000   8A82         MOV       DPL,R2
   \   000002   8B83         MOV       DPH,R3
   \   000004   A3           INC       DPTR
   \   000005   A3           INC       DPTR
   \   000006   E0           MOVX      A,@DPTR
   \   000007   F5..         MOV       ?V0,A
   \   000009   E4           CLR       A
   \   00000A   F5..         MOV       ?V1,A
   \   00000C   7410         MOV       A,#0x10
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   12....       LCALL     ?Subroutine24 & 0xFFFF
   \                     ??CrossCallReturnLabel_34:
   \   000003   78..         MOV       R0,#?V0
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine24:
   \   000000   A3           INC       DPTR
   \   000001   E0           MOVX      A,@DPTR
   \   000002   F5..         MOV       ?V0,A
   \   000004   E4           CLR       A
   \   000005   F5..         MOV       ?V1,A
   \   000007   F5..         MOV       ?V2,A
   \   000009   F5..         MOV       ?V3,A
   \   00000B   7408         MOV       A,#0x8
   \   00000D   22           RET
    371          
    372          #if !defined ( ZBIT ) && !defined ( ZBIT2 ) && !defined (UBIT)
    373          /*********************************************************************
    374           * @fn      _ltoa
    375           *
    376           * @brief
    377           *
    378           *   convert a long unsigned int to a string.
    379           *
    380           * @param  l - long to convert
    381           * @param  buf - buffer to convert to
    382           * @param  radix - 10 dec, 16 hex
    383           *
    384           * @return  pointer to buffer
    385           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    386          unsigned char * _ltoa(unsigned long l, unsigned char *buf, unsigned char radix)
   \                     _ltoa:
    387          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000                REQUIRE ?V14
   \   000000                REQUIRE ?V15
   \   000000   74E8         MOV       A,#-0x18
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 33
   \   000005   74DF         MOV       A,#-0x21
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   E9           MOV       A,R1
   \   00000B   85..82       MOV       DPL,?XSP + 0
   \   00000E   85..83       MOV       DPH,?XSP + 1
   \   000011   F0           MOVX      @DPTR,A
   \   000012   8A..         MOV       ?V8,R2
   \   000014   8B..         MOV       ?V9,R3
   \   000016   8C..         MOV       ?V10,R4
   \   000018   8D..         MOV       ?V11,R5
    388          #if defined (__TI_COMPILER_VERSION)
    389            return ( (unsigned char*)ltoa( l, (char *)buf ) );
    390          #elif defined( __GNUC__ )
    391            return ( (char*)ltoa( l, buf, radix ) );
    392          #else
    393            unsigned char tmp1[10] = "", tmp2[10] = "", tmp3[10] = "";
   \   00001A   90....       MOV       DPTR,#`?<Constant "">`
   \   00001D   7403         MOV       A,#0x3
   \   00001F   12....       LCALL     ?XSTACK_DISP102_8
   \   000022   740A         MOV       A,#0xa
   \   000024   12....       LCALL     ?MOVE_LONG8_XDATA_XDATA
   \   000027   90....       MOV       DPTR,#`?<Constant "">_1`
   \   00002A   740A         MOV       A,#0xa
   \   00002C   12....       LCALL     ?MOVE_LONG8_XDATA_XDATA
   \   00002F   90....       MOV       DPTR,#`?<Constant "">_2`
   \   000032   740A         MOV       A,#0xa
   \   000034   12....       LCALL     ?MOVE_LONG8_XDATA_XDATA
    394            unsigned short num1, num2, num3;
    395            unsigned char i;
    396          
    397            buf[0] = '\0';
   \   000037   7439         MOV       A,#0x39
   \   000039   12....       LCALL     ?XSTACK_DISP0_8
   \   00003C   12....       LCALL     ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_18:
   \   00003F   E4           CLR       A
   \   000040   F0           MOVX      @DPTR,A
    398          
    399            if ( radix == 10 )
   \   000041   04           INC       A
   \   000042   12....       LCALL     ?XSTACK_DISP0_8
   \   000045   74..         MOV       A,#`?<Constant "0">` & 0xff
   \   000047   F0           MOVX      @DPTR,A
   \   000048   A3           INC       DPTR
   \   000049   74..         MOV       A,#(`?<Constant "0">` >> 8) & 0xff
   \   00004B   F0           MOVX      @DPTR,A
   \   00004C   85..82       MOV       DPL,?XSP + 0
   \   00004F   85..83       MOV       DPH,?XSP + 1
   \   000052   E0           MOVX      A,@DPTR
   \   000053   640A         XRL       A,#0xa
   \   000055   6003         JZ        $+5
   \   000057   02....       LJMP      ??_ltoa_0 & 0xFFFF
    400            {
    401              num1 = l % 10000;
   \   00005A   8A..         MOV       ?V0,R2
   \   00005C   8B..         MOV       ?V1,R3
   \   00005E   85....       MOV       ?V2,?V10
   \   000061   85....       MOV       ?V3,?V11
   \   000064   90....       MOV       DPTR,#__Constant_2710
   \   000067   78..         MOV       R0,#?V4
   \   000069   12....       LCALL     ?L_MOV_X
   \   00006C   78..         MOV       R0,#?V0
   \   00006E   79..         MOV       R1,#?V4
   \   000070   12....       LCALL     ?UL_DIV_MOD
   \   000073   85....       MOV       ?V0,?V4
   \   000076   85....       MOV       ?V1,?V5
    402              num2 = (l / 10000) % 10000;
   \   000079   8A..         MOV       ?V4,R2
   \   00007B   8B..         MOV       ?V5,R3
   \   00007D   85....       MOV       ?V6,?V10
   \   000080   85....       MOV       ?V7,?V11
   \   000083   90....       MOV       DPTR,#__Constant_2710
   \   000086   78..         MOV       R0,#?V12
   \   000088   12....       LCALL     ?L_MOV_X
   \   00008B   78..         MOV       R0,#?V4
   \   00008D   79..         MOV       R1,#?V12
   \   00008F   12....       LCALL     ?UL_DIV_MOD
   \   000092   90....       MOV       DPTR,#__Constant_2710
   \   000095   78..         MOV       R0,#?V12
   \   000097   12....       LCALL     ?L_MOV_X
   \   00009A   78..         MOV       R0,#?V4
   \   00009C   79..         MOV       R1,#?V12
   \   00009E   12....       LCALL     ?UL_DIV_MOD
   \   0000A1   AE..         MOV       R6,?V12
   \   0000A3   AF..         MOV       R7,?V13
    403              num3 = (unsigned short)(l / 100000000);
   \   0000A5   90....       MOV       DPTR,#__Constant_5f5e100
   \   0000A8   78..         MOV       R0,#?V4
   \   0000AA   12....       LCALL     ?L_MOV_X
   \   0000AD   78..         MOV       R0,#?V8
   \   0000AF   79..         MOV       R1,#?V4
   \   0000B1   12....       LCALL     ?UL_DIV_MOD
   \   0000B4   85....       MOV       ?V2,?V8
   \   0000B7   85....       MOV       ?V3,?V9
    404          
    405              if (num3) _itoa(num3, tmp3, 10);
   \   0000BA   E5..         MOV       A,?V2
   \   0000BC   45..         ORL       A,?V3
   \   0000BE   600E         JZ        ??_ltoa_1
   \   0000C0                ; Setup parameters for call to function _itoa
   \   0000C0   790A         MOV       R1,#0xa
   \   0000C2   7417         MOV       A,#0x17
   \   0000C4   12....       LCALL     ?XSTACK_DISP102_8
   \   0000C7   AA..         MOV       R2,?V2
   \   0000C9   AB..         MOV       R3,?V3
   \   0000CB   12....       LCALL     `??_itoa::?relay`; Banked call to: _itoa
    406              if (num2) _itoa(num2, tmp2, 10);
   \                     ??_ltoa_1:
   \   0000CE   EE           MOV       A,R6
   \   0000CF   4F           ORL       A,R7
   \   0000D0   600E         JZ        ??_ltoa_2
   \   0000D2                ; Setup parameters for call to function _itoa
   \   0000D2   790A         MOV       R1,#0xa
   \   0000D4   740D         MOV       A,#0xd
   \   0000D6   12....       LCALL     ?XSTACK_DISP102_8
   \   0000D9   EE           MOV       A,R6
   \   0000DA   FA           MOV       R2,A
   \   0000DB   EF           MOV       A,R7
   \   0000DC   FB           MOV       R3,A
   \   0000DD   12....       LCALL     `??_itoa::?relay`; Banked call to: _itoa
    407              if (num1) _itoa(num1, tmp1, 10);
   \                     ??_ltoa_2:
   \   0000E0   E5..         MOV       A,?V0
   \   0000E2   45..         ORL       A,?V1
   \   0000E4   600E         JZ        ??_ltoa_3
   \   0000E6                ; Setup parameters for call to function _itoa
   \   0000E6   790A         MOV       R1,#0xa
   \   0000E8   7403         MOV       A,#0x3
   \   0000EA   12....       LCALL     ?XSTACK_DISP102_8
   \   0000ED   AA..         MOV       R2,?V0
   \   0000EF   AB..         MOV       R3,?V1
   \   0000F1   12....       LCALL     `??_itoa::?relay`; Banked call to: _itoa
    408          
    409              if (num3)
   \                     ??_ltoa_3:
   \   0000F4   E5..         MOV       A,?V2
   \   0000F6   45..         ORL       A,?V3
   \   0000F8   602B         JZ        ??_ltoa_4
    410              {
    411                strcpy((char*)buf, (char const*)tmp3);
   \   0000FA                ; Setup parameters for call to function strcpy
   \   0000FA   7417         MOV       A,#0x17
   \   0000FC   12....       LCALL     ?XSTACK_DISP102_8
   \   0000FF   7439         MOV       A,#0x39
   \   000101   12....       LCALL     ?XSTACK_DISP0_8
   \   000104   12....       LCALL     ?Subroutine12 & 0xFFFF
    412                for (i = 0; i < 4 - strlen((char const*)tmp2); i++)
   \                     ??CrossCallReturnLabel_13:
   \   000107   800E         SJMP      ??CrossCallReturnLabel_2
    413                  strcat((char*)buf, "0");
   \                     ??_ltoa_5:
   \   000109                ; Setup parameters for call to function strcat
   \   000109   7401         MOV       A,#0x1
   \   00010B   12....       LCALL     ?XSTACK_DISP0_8
   \   00010E   12....       LCALL     ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_5:
   \   000111   12....       LCALL     ?XSTACK_DISP0_8
   \   000114   12....       LCALL     ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_2:
   \   000117   E5..         MOV       A,?V4
   \   000119   F5..         MOV       ?V6,A
   \   00011B                ; Setup parameters for call to function strlen
   \   00011B   740D         MOV       A,#0xd
   \   00011D   12....       LCALL     ?XSTACK_DISP101_8
   \   000120   12....       LCALL     ?Subroutine6 & 0xFFFF
    414              }
   \                     ??CrossCallReturnLabel_0:
   \   000123   40E4         JC        ??_ltoa_5
    415              strcat((char*)buf, (char const*)tmp2);
   \                     ??_ltoa_4:
   \   000125                ; Setup parameters for call to function strcat
   \   000125   740D         MOV       A,#0xd
   \   000127   12....       LCALL     ?XSTACK_DISP102_8
   \   00012A   7439         MOV       A,#0x39
   \   00012C   12....       LCALL     ?XSTACK_DISP0_8
   \   00012F   12....       LCALL     ?Subroutine11 & 0xFFFF
    416              if (num3 || num2)
   \                     ??CrossCallReturnLabel_11:
   \   000132   7004         JNZ       ??_ltoa_6
   \   000134   EE           MOV       A,R6
   \   000135   4F           ORL       A,R7
   \   000136   6021         JZ        ??_ltoa_7
    417              {
    418                for (i = 0; i < 4 - strlen((char const*)tmp1); i++)
   \                     ??_ltoa_6:
   \   000138   75..00       MOV       ?V4,#0x0
   \   00013B   800E         SJMP      ??CrossCallReturnLabel_3
    419                  strcat((char*)buf, "0");
   \                     ??_ltoa_8:
   \   00013D                ; Setup parameters for call to function strcat
   \   00013D   7401         MOV       A,#0x1
   \   00013F   12....       LCALL     ?XSTACK_DISP0_8
   \   000142   12....       LCALL     ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_6:
   \   000145   12....       LCALL     ?XSTACK_DISP0_8
   \   000148   12....       LCALL     ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_3:
   \   00014B   E5..         MOV       A,?V4
   \   00014D   F5..         MOV       ?V6,A
   \   00014F                ; Setup parameters for call to function strlen
   \   00014F   7403         MOV       A,#0x3
   \   000151   12....       LCALL     ?XSTACK_DISP101_8
   \   000154   12....       LCALL     ?Subroutine6 & 0xFFFF
    420              }
   \                     ??CrossCallReturnLabel_1:
   \   000157   40E4         JC        ??_ltoa_8
    421              strcat((char*)buf, (char const*)tmp1);
   \                     ??_ltoa_7:
   \   000159                ; Setup parameters for call to function strcat
   \   000159   7403         MOV       A,#0x3
   \   00015B   12....       LCALL     ?XSTACK_DISP102_8
   \   00015E   7439         MOV       A,#0x39
   \   000160   12....       LCALL     ?XSTACK_DISP0_8
   \   000163   12....       LCALL     ?Subroutine11 & 0xFFFF
    422              if (!num3 && !num2 && !num1)
    423                strcpy((char*)buf, "0");
    424            }
   \                     ??CrossCallReturnLabel_12:
   \   000166   7007         JNZ       ??_ltoa_9
   \   000168   EE           MOV       A,R6
   \   000169   4F           ORL       A,R7
   \   00016A   7003         JNZ       $+5
   \   00016C   02....       LJMP      ??_ltoa_10 & 0xFFFF
    425            else if ( radix == 16 )
    426            {
    427              num1 = l & 0x0000FFFF;
    428              num2 = l >> 16;
    429          
    430              if (num2) _itoa(num2, tmp2, 16);
    431              if (num1) _itoa(num1, tmp1, 16);
    432          
    433              if (num2)
    434              {
    435                strcpy((char*)buf,(char const*)tmp2);
    436                for (i = 0; i < 4 - strlen((char const*)tmp1); i++)
    437                  strcat((char*)buf, "0");
    438              }
    439              strcat((char*)buf, (char const*)tmp1);
    440              if (!num2 && !num1)
    441                strcpy((char*)buf, "0");
    442            }
    443            else
    444              return NULL;
    445          
    446            return buf;
   \                     ??_ltoa_9:
   \   00016F   7439         MOV       A,#0x39
   \   000171   12....       LCALL     ?XSTACK_DISP0_8
   \   000174   12....       LCALL     ??Subroutine32_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_58:
   \   000177   7421         MOV       A,#0x21
   \   000179   12....       LCALL     ?DEALLOC_XSTACK8
   \   00017C   7F10         MOV       R7,#0x10
   \   00017E   02....       LJMP      ?BANKED_LEAVE_XDATA
   \                     ??_ltoa_0:
   \   000181   E0           MOVX      A,@DPTR
   \   000182   6410         XRL       A,#0x10
   \   000184   6003         JZ        $+5
   \   000186   02....       LJMP      ??_ltoa_11 & 0xFFFF
   \   000189   8A..         MOV       ?V0,R2
   \   00018B   8B..         MOV       ?V1,R3
   \   00018D   7410         MOV       A,#0x10
   \   00018F   78..         MOV       R0,#?V8
   \   000191   12....       LCALL     ?UL_SHR
   \   000194   AE..         MOV       R6,?V8
   \   000196   AF..         MOV       R7,?V9
   \   000198   EE           MOV       A,R6
   \   000199   4F           ORL       A,R7
   \   00019A   600E         JZ        ??_ltoa_12
   \   00019C                ; Setup parameters for call to function _itoa
   \   00019C   7910         MOV       R1,#0x10
   \   00019E   740D         MOV       A,#0xd
   \   0001A0   12....       LCALL     ?XSTACK_DISP102_8
   \   0001A3   EE           MOV       A,R6
   \   0001A4   FA           MOV       R2,A
   \   0001A5   EF           MOV       A,R7
   \   0001A6   FB           MOV       R3,A
   \   0001A7   12....       LCALL     `??_itoa::?relay`; Banked call to: _itoa
   \                     ??_ltoa_12:
   \   0001AA   E5..         MOV       A,?V0
   \   0001AC   45..         ORL       A,?V1
   \   0001AE   600E         JZ        ??_ltoa_13
   \   0001B0                ; Setup parameters for call to function _itoa
   \   0001B0   7910         MOV       R1,#0x10
   \   0001B2   7403         MOV       A,#0x3
   \   0001B4   12....       LCALL     ?XSTACK_DISP102_8
   \   0001B7   AA..         MOV       R2,?V0
   \   0001B9   AB..         MOV       R3,?V1
   \   0001BB   12....       LCALL     `??_itoa::?relay`; Banked call to: _itoa
   \                     ??_ltoa_13:
   \   0001BE   EE           MOV       A,R6
   \   0001BF   4F           ORL       A,R7
   \   0001C0   603F         JZ        ??_ltoa_14
   \   0001C2                ; Setup parameters for call to function strcpy
   \   0001C2   740D         MOV       A,#0xd
   \   0001C4   12....       LCALL     ?XSTACK_DISP102_8
   \   0001C7   7439         MOV       A,#0x39
   \   0001C9   12....       LCALL     ?XSTACK_DISP0_8
   \   0001CC   12....       LCALL     ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_14:
   \   0001CF   800E         SJMP      ??CrossCallReturnLabel_4
   \                     ??_ltoa_15:
   \   0001D1                ; Setup parameters for call to function strcat
   \   0001D1   7401         MOV       A,#0x1
   \   0001D3   12....       LCALL     ?XSTACK_DISP0_8
   \   0001D6   12....       LCALL     ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_7:
   \   0001D9   12....       LCALL     ?XSTACK_DISP0_8
   \   0001DC   12....       LCALL     ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_4:
   \   0001DF   E5..         MOV       A,?V4
   \   0001E1   F5..         MOV       ?V2,A
   \   0001E3                ; Setup parameters for call to function strlen
   \   0001E3   7403         MOV       A,#0x3
   \   0001E5   12....       LCALL     ?XSTACK_DISP101_8
   \   0001E8   12....       LCALL     `??strlen::?relay`; Banked call to: strlen
   \   0001EB   8A..         MOV       ?V6,R2
   \   0001ED   8B..         MOV       ?V7,R3
   \   0001EF   7404         MOV       A,#0x4
   \   0001F1   C3           CLR       C
   \   0001F2   95..         SUBB      A,?V6
   \   0001F4   F8           MOV       R0,A
   \   0001F5   E4           CLR       A
   \   0001F6   95..         SUBB      A,?V7
   \   0001F8   F9           MOV       R1,A
   \   0001F9   C3           CLR       C
   \   0001FA   E5..         MOV       A,?V2
   \   0001FC   98           SUBB      A,R0
   \   0001FD   E4           CLR       A
   \   0001FE   99           SUBB      A,R1
   \   0001FF   40D0         JC        ??_ltoa_15
   \                     ??_ltoa_14:
   \   000201                ; Setup parameters for call to function strcat
   \   000201   7403         MOV       A,#0x3
   \   000203   12....       LCALL     ?XSTACK_DISP102_8
   \   000206   7439         MOV       A,#0x39
   \   000208   12....       LCALL     ?XSTACK_DISP0_8
   \   00020B   12....       LCALL     ??Subroutine32_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_59:
   \   00020E   12....       LCALL     `??strcat::?relay`; Banked call to: strcat
   \   000211   EE           MOV       A,R6
   \   000212   4F           ORL       A,R7
   \   000213   6003         JZ        $+5
   \   000215   02....       LJMP      ??_ltoa_9 & 0xFFFF
   \                     ??_ltoa_10:
   \   000218   E5..         MOV       A,?V0
   \   00021A   45..         ORL       A,?V1
   \   00021C   6003         JZ        $+5
   \   00021E   02....       LJMP      ??_ltoa_9 & 0xFFFF
   \   000221                ; Setup parameters for call to function strcpy
   \   000221   7401         MOV       A,#0x1
   \   000223   12....       LCALL     ?XSTACK_DISP0_8
   \   000226   12....       LCALL     ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_8:
   \   000229   12....       LCALL     ?XSTACK_DISP0_8
   \   00022C   12....       LCALL     ??Subroutine32_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_60:
   \   00022F   12....       LCALL     `??strcpy::?relay`; Banked call to: strcpy
   \   000232   02....       LJMP      ??_ltoa_9 & 0xFFFF
   \                     ??_ltoa_11:
   \   000235   7A00         MOV       R2,#0x0
   \   000237   7B00         MOV       R3,#0x0
   \   000239   02....       LJMP      ??CrossCallReturnLabel_58 & 0xFFFF
    447          #endif
    448          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   FA           MOV       R2,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   FB           MOV       R3,A
   \   000005   12....       LCALL     `??strcpy::?relay`; Banked call to: strcpy
   \   000008   75..00       MOV       ?V4,#0x0
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000   12....       LCALL     ?Subroutine25 & 0xFFFF
   \                     ??CrossCallReturnLabel_35:
   \   000003   E5..         MOV       A,?V2
   \   000005   45..         ORL       A,?V3
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   FC           MOV       R4,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   FD           MOV       R5,A
   \   000005   7439         MOV       A,#0x39
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   12....       LCALL     ?Subroutine25 & 0xFFFF
   \                     ??CrossCallReturnLabel_36:
   \   000003   05..         INC       ?V4
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine25:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   FA           MOV       R2,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   FB           MOV       R3,A
   \   000005   12....       LCALL     `??strcat::?relay`; Banked call to: strcat
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   12....       LCALL     `??strlen::?relay`; Banked call to: strlen
   \   000003   8A..         MOV       ?V8,R2
   \   000005   8B..         MOV       ?V9,R3
   \   000007   7404         MOV       A,#0x4
   \   000009   C3           CLR       C
   \   00000A   95..         SUBB      A,?V8
   \   00000C   F8           MOV       R0,A
   \   00000D   E4           CLR       A
   \   00000E   95..         SUBB      A,?V9
   \   000010   F9           MOV       R1,A
   \   000011   C3           CLR       C
   \   000012   E5..         MOV       A,?V6
   \   000014   98           SUBB      A,R0
   \   000015   E4           CLR       A
   \   000016   99           SUBB      A,R1
   \   000017   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine15:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F8           MOV       R0,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   F583         MOV       DPH,A
   \   000006   8882         MOV       DPL,R0
   \   000008   22           RET
    449          #endif // !defined(ZBIT) && !defined(ZBIT2)
    450          
    451          /*********************************************************************
    452           * @fn        osal_rand
    453           *
    454           * @brief    Random number generator
    455           *
    456           * @param   none
    457           *
    458           * @return  uint16 - new random number
    459           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    460          uint16 osal_rand( void )
   \                     osal_rand:
    461          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    462            return ( Onboard_rand() );
   \   000004                ; Setup parameters for call to function Onboard_rand
   \   000004   12....       LCALL     `??Onboard_rand::?relay`; Banked call to: Onboard_rand
   \   000007   80..         SJMP      ?Subroutine0
    463          }
    464          
    465          /*********************************************************************
    466           * API FUNCTIONS
    467           *********************************************************************/
    468          
    469          #ifdef USE_ICALL
    470          /*********************************************************************
    471           * @fn      osal_prepare_svc_enroll
    472           *
    473           * @brief   Initialize data structures that map OSAL task ids to
    474           *          ICall entity ids.
    475           *
    476           * @param   none
    477           *
    478           * @return  none
    479           */
    480          static void osal_prepare_svc_enroll(void)
    481          {
    482            osal_dispatch_entities = (uint8 *) osal_mem_alloc(tasksCnt * 2);
    483            osal_memset(osal_dispatch_entities, OSAL_INVALID_DISPATCH_ID, tasksCnt * 2);
    484            osal_memset(osal_proxy_tasks, OSAL_INVALID_DISPATCH_ID,
    485                        OSAL_MAX_NUM_PROXY_TASKS);
    486          }
    487          
    488          /*********************************************************************
    489           * @fn      osal_enroll_dispatchid
    490           *
    491           * @brief   Map a task id to an ICall entity id for messaging in
    492           *          both directions (sending and receiving).
    493           *
    494           * @param   taskid       OSAL task id
    495           * @param   dispatchid   ICall entity id
    496           *
    497           * @return  none
    498           */
    499          void osal_enroll_dispatchid(uint8 taskid, ICall_EntityID dispatchid)
    500          {
    501            osal_dispatch_entities[taskid] = dispatchid;
    502            osal_dispatch_entities[tasksCnt + taskid] = dispatchid;
    503          }
    504          
    505          /*********************************************************************
    506           * @fn      osal_enroll_senderid
    507           *
    508           * @brief   Map a task id to an ICall entity id, which shall be used
    509           *          just for sending a message from an OSAL task.
    510           *          Note that osal_enroll_dispatchid() must never be called
    511           *          with the same OSAL task id used in this function call.
    512           *          However, it is OK to call osal_enroll_dispatchid()
    513           *          with the same ICall entity id and a different OSAL task id.
    514           *
    515           * @param   taskid       OSAL task id
    516           * @param   dispatchid   ICall entity id
    517           *
    518           * @return  none
    519           */
    520          void osal_enroll_senderid(uint8 taskid, ICall_EntityID dispatchid)
    521          {
    522            osal_dispatch_entities[tasksCnt + taskid] = dispatchid;
    523          }
    524          
    525          /*********************************************************************
    526           * @fn      osal_enroll_notasksender
    527           *
    528           * @brief   Map no task id to an ICall entity id, which shall be used
    529           *          just for sending a message from non-OSAL task.
    530           *
    531           * @param   dispatchid   ICall entity id
    532           *
    533           * @return  none
    534           */
    535          void osal_enroll_notasksender(ICall_EntityID dispatchid)
    536          {
    537            osal_notask_entity = dispatchid;
    538          }
    539          #endif /* USE_ICALL */
    540          
    541          /*********************************************************************
    542           * @fn      osal_msg_allocate
    543           *
    544           * @brief
    545           *
    546           *    This function is called by a task to allocate a message buffer
    547           *    into which the task will encode the particular message it wishes
    548           *    to send.  This common buffer scheme is used to strictly limit the
    549           *    creation of message buffers within the system due to RAM size
    550           *    limitations on the microprocessor.   Note that all message buffers
    551           *    are a fixed size (at least initially).  The parameter len is kept
    552           *    in case a message pool with varying fixed message sizes is later
    553           *    created (for example, a pool of message buffers of size LARGE,
    554           *    MEDIUM and SMALL could be maintained and allocated based on request
    555           *    from the tasks).
    556           *
    557           *
    558           * @param   uint8 len  - wanted buffer length
    559           *
    560           *
    561           * @return  pointer to allocated buffer or NULL if allocation failed.
    562           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    563          uint8 * osal_msg_allocate( uint16 len )
   \                     osal_msg_allocate:
    564          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   FF           MOV       R7,A
    565            osal_msg_hdr_t *hdr;
    566          
    567            if ( len == 0 )
   \   000009   EA           MOV       A,R2
   \   00000A   4F           ORL       A,R7
   \   00000B   6031         JZ        ??osal_msg_allocate_0
    568              return ( NULL );
    569          
    570            hdr = (osal_msg_hdr_t *) osal_mem_alloc( (short)(len + sizeof( osal_msg_hdr_t )) );
   \   00000D                ; Setup parameters for call to function osal_mem_alloc
   \   00000D   EA           MOV       A,R2
   \   00000E   2405         ADD       A,#0x5
   \   000010   FA           MOV       R2,A
   \   000011   E4           CLR       A
   \   000012   3F           ADDC      A,R7
   \   000013   FB           MOV       R3,A
   \   000014   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000017   8B..         MOV       ?V1,R3
   \   000019   A9..         MOV       R1,?V1
    571            if ( hdr )
   \   00001B   EA           MOV       A,R2
   \   00001C   49           ORL       A,R1
   \   00001D   601F         JZ        ??osal_msg_allocate_0
    572            {
    573              hdr->next = NULL;
   \   00001F   8A82         MOV       DPL,R2
   \   000021   8B83         MOV       DPH,R3
   \   000023   E4           CLR       A
   \   000024   F0           MOVX      @DPTR,A
   \   000025   A3           INC       DPTR
   \   000026   12....       LCALL     ??Subroutine28_0 & 0xFFFF
    574              hdr->len = len;
   \                     ??CrossCallReturnLabel_39:
   \   000029   A3           INC       DPTR
   \   00002A   A3           INC       DPTR
   \   00002B   12....       LCALL     ?Subroutine20 & 0xFFFF
    575              hdr->dest_id = TASK_NO_TASK;
   \                     ??CrossCallReturnLabel_37:
   \   00002E   A3           INC       DPTR
   \   00002F   A3           INC       DPTR
   \   000030   A3           INC       DPTR
   \   000031   A3           INC       DPTR
   \   000032   74FF         MOV       A,#-0x1
   \   000034   F0           MOVX      @DPTR,A
    576              return ( (uint8 *) (hdr + 1) );
   \   000035   EA           MOV       A,R2
   \   000036   2405         ADD       A,#0x5
   \   000038   FA           MOV       R2,A
   \   000039   E4           CLR       A
   \   00003A   39           ADDC      A,R1
   \   00003B   FB           MOV       R3,A
   \   00003C   8004         SJMP      ??osal_msg_allocate_1
    577            }
    578            else
    579              return ( NULL );
   \                     ??osal_msg_allocate_0:
   \   00003E   7A00         MOV       R2,#0x0
   \   000040   7B00         MOV       R3,#0x0
   \                     ??osal_msg_allocate_1:
   \   000042   02....       LJMP      ?Subroutine2 & 0xFFFF
    580          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine20:
   \   000000   EE           MOV       A,R6
   \   000001   F0           MOVX      @DPTR,A
   \   000002   A3           INC       DPTR
   \   000003   EF           MOV       A,R7
   \   000004                REQUIRE ??Subroutine28_0
   \   000004                ; // Fall through to label ??Subroutine28_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine28_0:
   \   000000   F0           MOVX      @DPTR,A
   \   000001   8A82         MOV       DPL,R2
   \   000003   8B83         MOV       DPH,R3
   \   000005   22           RET
    581          
    582          /*********************************************************************
    583           * @fn      osal_msg_deallocate
    584           *
    585           * @brief
    586           *
    587           *    This function is used to deallocate a message buffer. This function
    588           *    is called by a task (or processing element) after it has finished
    589           *    processing a received message.
    590           *
    591           *
    592           * @param   uint8 *msg_ptr - pointer to new message buffer
    593           *
    594           * @return  SUCCESS, INVALID_MSG_POINTER
    595           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    596          uint8 osal_msg_deallocate( uint8 *msg_ptr )
   \                     osal_msg_deallocate:
    597          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    598            uint8 *x;
    599          
    600            if ( msg_ptr == NULL )
   \   000004   EA           MOV       A,R2
   \   000005   4B           ORL       A,R3
   \   000006   7004         JNZ       ??osal_msg_deallocate_0
    601              return ( INVALID_MSG_POINTER );
   \   000008   7905         MOV       R1,#0x5
   \   00000A   8016         SJMP      ??osal_msg_deallocate_1
    602          
    603            // don't deallocate queued buffer
    604            if ( OSAL_MSG_ID( msg_ptr ) != TASK_NO_TASK )
   \                     ??osal_msg_deallocate_0:
   \   00000C   12....       LCALL     ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_24:
   \   00000F   6004         JZ        ??osal_msg_deallocate_2
    605              return ( MSG_BUFFER_NOT_AVAIL );
   \   000011   7904         MOV       R1,#0x4
   \   000013   800D         SJMP      ??osal_msg_deallocate_1
    606          
    607            x = (uint8 *)((uint8 *)msg_ptr - sizeof( osal_msg_hdr_t ));
    608          
    609            osal_mem_free( (void *)x );
   \                     ??osal_msg_deallocate_2:
   \   000015                ; Setup parameters for call to function osal_mem_free
   \   000015   EA           MOV       A,R2
   \   000016   24FB         ADD       A,#-0x5
   \   000018   FA           MOV       R2,A
   \   000019   EB           MOV       A,R3
   \   00001A   34FF         ADDC      A,#-0x1
   \   00001C   FB           MOV       R3,A
   \   00001D   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
    610          
    611            return ( SUCCESS );
   \   000020   7900         MOV       R1,#0x0
   \                     ??osal_msg_deallocate_1:
   \   000022                REQUIRE ?Subroutine0
   \   000022                ; // Fall through to label ?Subroutine0
    612          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine18:
   \   000000   EA           MOV       A,R2
   \   000001   24FF         ADD       A,#-0x1
   \   000003   F582         MOV       DPL,A
   \   000005   EB           MOV       A,R3
   \   000006   34FF         ADDC      A,#-0x1
   \   000008   F583         MOV       DPH,A
   \   00000A   E0           MOVX      A,@DPTR
   \   00000B   F4           CPL       A
   \   00000C   22           RET
    613          
    614          /*********************************************************************
    615           * @fn      osal_msg_send
    616           *
    617           * @brief
    618           *
    619           *    This function is called by a task to send a command message to
    620           *    another task or processing element.  The sending_task field must
    621           *    refer to a valid task, since the task ID will be used
    622           *    for the response message.  This function will also set a message
    623           *    ready event in the destination tasks event list.
    624           *
    625           *
    626           * @param   uint8 destination_task - Send msg to Task ID
    627           * @param   uint8 *msg_ptr - pointer to new message buffer
    628           *
    629           * @return  SUCCESS, INVALID_TASK, INVALID_MSG_POINTER
    630           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    631          uint8 osal_msg_send( uint8 destination_task, uint8 *msg_ptr )
   \                     osal_msg_send:
    632          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    633          #ifdef USE_ICALL
    634            if (destination_task & OSAL_PROXY_ID_FLAG)
    635            {
    636              /* Destination is a proxy task */
    637              osal_msg_hdr_t *hdr = (osal_msg_hdr_t *)msg_ptr - 1;
    638              ICall_EntityID src, dst;
    639          
    640              uint8 taskid = osal_self();
    641              if (taskid == TASK_NO_TASK)
    642              {
    643                /* Call must have been made from either an ISR or a user-thread */
    644                src = osal_notask_entity;
    645              }
    646              else
    647              {
    648                src = (ICall_EntityID) osal_dispatch_entities[taskid + tasksCnt];
    649              }
    650              if (src == OSAL_INVALID_DISPATCH_ID)
    651              {
    652                /* The source entity is not registered */
    653                /* abort */
    654                ICall_abort();
    655                return FAILURE;
    656              }
    657              dst = osal_proxy2alien(destination_task);
    658              hdr->dest_id = TASK_NO_TASK;
    659              if (ICall_send(src, dst, ICALL_MSG_FORMAT_KEEP, msg_ptr) ==
    660                  ICALL_ERRNO_SUCCESS)
    661              {
    662                return SUCCESS;
    663              }
    664              osal_msg_deallocate(msg_ptr);
    665              return FAILURE;
    666            }
    667          #endif /* USE_ICALL */
    668            return ( osal_msg_enqueue_push( destination_task, msg_ptr, FALSE ) );
   \   000005                ; Setup parameters for call to function osal_msg_enqueue_push
   \   000005   7C00         MOV       R4,#0x0
   \   000007                REQUIRE ?Subroutine5
   \   000007                ; // Fall through to label ?Subroutine5
    669          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   12....       LCALL     `??osal_msg_enqueue_push::?relay`; Banked call to: osal_msg_enqueue_push
   \   000003   02....       LJMP      ??Subroutine27_0 & 0xFFFF
    670          
    671          /*********************************************************************
    672           * @fn      osal_msg_push_front
    673           *
    674           * @brief
    675           *
    676           *    This function is called by a task to push a command message
    677           *    to the head of the OSAL queue. The destination_task field
    678           *    must refer to a valid task, since the task ID will be used to
    679           *    send the message to. This function will also set a message
    680           *    ready event in the destination task's event list.
    681           *
    682           * @param   uint8 destination_task - Send msg to Task ID
    683           * @param   uint8 *msg_ptr - pointer to message buffer
    684           *
    685           * @return  SUCCESS, INVALID_TASK, INVALID_MSG_POINTER
    686           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    687          uint8 osal_msg_push_front( uint8 destination_task, uint8 *msg_ptr )
   \                     osal_msg_push_front:
    688          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    689            return ( osal_msg_enqueue_push( destination_task, msg_ptr, TRUE ) );
   \   000005                ; Setup parameters for call to function osal_msg_enqueue_push
   \   000005   7C01         MOV       R4,#0x1
   \   000007   80..         SJMP      ?Subroutine5
    690          }
    691          
    692          /*********************************************************************
    693           * @fn      osal_msg_enqueue_push
    694           *
    695           * @brief
    696           *
    697           *    This function is called by a task to either enqueue (append to
    698           *    queue) or push (prepend to queue) a command message to the OSAL
    699           *    queue. The destination_task field must refer to a valid task,
    700           *    since the task ID will be used to send the message to. This 
    701           *    function will also set a message ready event in the destination
    702           *    task's event list.
    703           *
    704           * @param   uint8 destination_task - Send msg to Task ID
    705           * @param   uint8 *msg_ptr - pointer to message buffer
    706           * @param   uint8 push - TRUE to push, otherwise enqueue
    707           *
    708           * @return  SUCCESS, INVALID_TASK, INVALID_MSG_POINTER
    709           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    710          static uint8 osal_msg_enqueue_push( uint8 destination_task, uint8 *msg_ptr, uint8 push )
   \                     osal_msg_enqueue_push:
    711          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV       A,R1
   \   000006   FE           MOV       R6,A
   \   000007   EC           MOV       A,R4
   \   000008   FF           MOV       R7,A
    712            if ( msg_ptr == NULL )
   \   000009   EA           MOV       A,R2
   \   00000A   4B           ORL       A,R3
   \   00000B   6026         JZ        ??osal_msg_enqueue_push_0
    713            {
    714              return ( INVALID_MSG_POINTER );
    715            }
    716          
    717          #ifdef USE_ICALL
    718            if (destination_task & OSAL_PROXY_ID_FLAG)
    719            {
    720              ICall_abort();
    721            }
    722          #endif /* USE_ICALL */
    723          
    724            if ( destination_task >= tasksCnt )
   \   00000D   90....       MOV       DPTR,#tasksCnt
   \   000010   E0           MOVX      A,@DPTR
   \   000011   F8           MOV       R0,A
   \   000012   E9           MOV       A,R1
   \   000013   C3           CLR       C
   \   000014   98           SUBB      A,R0
   \   000015   4007         JC        ??osal_msg_enqueue_push_1
    725            {
    726              osal_msg_deallocate( msg_ptr );
   \   000017                ; Setup parameters for call to function osal_msg_deallocate
   \   000017   12....       LCALL     `??osal_msg_deallocate::?relay`; Banked call to: osal_msg_deallocate
    727              return ( INVALID_TASK );
   \   00001A   7903         MOV       R1,#0x3
   \   00001C   8043         SJMP      ??osal_msg_enqueue_push_2
    728            }
    729          
    730            // Check the message header
    731            if ( OSAL_MSG_NEXT( msg_ptr ) != NULL ||
    732                 OSAL_MSG_ID( msg_ptr ) != TASK_NO_TASK )
   \                     ??osal_msg_enqueue_push_1:
   \   00001E   EA           MOV       A,R2
   \   00001F   24FB         ADD       A,#-0x5
   \   000021   F582         MOV       DPL,A
   \   000023   EB           MOV       A,R3
   \   000024   34FF         ADDC      A,#-0x1
   \   000026   12....       LCALL     ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_55:
   \   000029   7005         JNZ       ??osal_msg_enqueue_push_3
   \   00002B   12....       LCALL     ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_25:
   \   00002E   6007         JZ        ??osal_msg_enqueue_push_4
    733            {
    734              osal_msg_deallocate( msg_ptr );
   \                     ??osal_msg_enqueue_push_3:
   \   000030                ; Setup parameters for call to function osal_msg_deallocate
   \   000030   12....       LCALL     `??osal_msg_deallocate::?relay`; Banked call to: osal_msg_deallocate
    735              return ( INVALID_MSG_POINTER );
   \                     ??osal_msg_enqueue_push_0:
   \   000033   7905         MOV       R1,#0x5
   \   000035   802A         SJMP      ??osal_msg_enqueue_push_2
    736            }
    737          
    738            OSAL_MSG_ID( msg_ptr ) = destination_task;
   \                     ??osal_msg_enqueue_push_4:
   \   000037   EE           MOV       A,R6
   \   000038   F0           MOVX      @DPTR,A
    739          
    740            if ( push == TRUE )
   \   000039   7401         MOV       A,#0x1
   \   00003B   6F           XRL       A,R7
   \   00003C   700D         JNZ       ??osal_msg_enqueue_push_5
    741            {
    742              // prepend the message
    743              osal_msg_push( &osal_qHead, msg_ptr );
   \   00003E                ; Setup parameters for call to function osal_msg_push
   \   00003E   EA           MOV       A,R2
   \   00003F   FC           MOV       R4,A
   \   000040   EB           MOV       A,R3
   \   000041   FD           MOV       R5,A
   \   000042   7A..         MOV       R2,#osal_qHead & 0xff
   \   000044   7B..         MOV       R3,#(osal_qHead >> 8) & 0xff
   \   000046   12....       LCALL     `??osal_msg_push::?relay`; Banked call to: osal_msg_push
   \   000049   800B         SJMP      ??osal_msg_enqueue_push_6
    744            }
    745            else
    746            {
    747              // append the message
    748              osal_msg_enqueue( &osal_qHead, msg_ptr );
   \                     ??osal_msg_enqueue_push_5:
   \   00004B                ; Setup parameters for call to function osal_msg_enqueue
   \   00004B   EA           MOV       A,R2
   \   00004C   FC           MOV       R4,A
   \   00004D   EB           MOV       A,R3
   \   00004E   FD           MOV       R5,A
   \   00004F   7A..         MOV       R2,#osal_qHead & 0xff
   \   000051   7B..         MOV       R3,#(osal_qHead >> 8) & 0xff
   \   000053   12....       LCALL     `??osal_msg_enqueue::?relay`; Banked call to: osal_msg_enqueue
    749            }
    750          
    751            // Signal the task that a message is waiting
    752            osal_set_event( destination_task, SYS_EVENT_MSG );
   \                     ??osal_msg_enqueue_push_6:
   \   000056                ; Setup parameters for call to function osal_set_event
   \   000056   7A00         MOV       R2,#0x0
   \   000058   7B80         MOV       R3,#-0x80
   \   00005A   EE           MOV       A,R6
   \   00005B   F9           MOV       R1,A
   \   00005C   12....       LCALL     `??osal_set_event::?relay`; Banked call to: osal_set_event
    753          
    754            return ( SUCCESS );
   \   00005F   7900         MOV       R1,#0x0
   \                     ??osal_msg_enqueue_push_2:
   \   000061   02....       LJMP      ??Subroutine27_0 & 0xFFFF
    755          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   F583         MOV       DPH,A
   \   000002                REQUIRE ??Subroutine31_0
   \   000002                ; // Fall through to label ??Subroutine31_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine31_0:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F8           MOV       R0,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   F9           MOV       R1,A
   \   000005   E8           MOV       A,R0
   \   000006   49           ORL       A,R1
   \   000007   22           RET
    756          
    757          /*********************************************************************
    758           * @fn      osal_msg_receive
    759           *
    760           * @brief
    761           *
    762           *    This function is called by a task to retrieve a received command
    763           *    message. The calling task must deallocate the message buffer after
    764           *    processing the message using the osal_msg_deallocate() call.
    765           *
    766           * @param   uint8 task_id - receiving tasks ID
    767           *
    768           * @return  *uint8 - message information or NULL if no message
    769           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    770          uint8 *osal_msg_receive( uint8 task_id )
   \                     osal_msg_receive:
    771          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV       A,#-0xe
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
    772            osal_msg_hdr_t *listHdr;
    773            osal_msg_hdr_t *prevHdr = NULL;
   \   000005   75..00       MOV       ?V4,#0x0
   \   000008   75..00       MOV       ?V5,#0x0
    774            osal_msg_hdr_t *foundHdr = NULL;
   \   00000B   7E00         MOV       R6,#0x0
   \   00000D   7F00         MOV       R7,#0x0
    775            halIntState_t   intState;
    776          
    777            // Hold off interrupts
    778            HAL_ENTER_CRITICAL_SECTION(intState);
   \   00000F   A2AF         MOV       C,0xa8.7
   \   000011   E4           CLR       A
   \   000012   33           RLC       A
   \   000013   F5..         MOV       ?V2,A
   \   000015   C2AF         CLR       0xa8.7
    779          
    780            // Point to the top of the queue
    781            listHdr = osal_qHead;
   \   000017   90....       MOV       DPTR,#osal_qHead
   \   00001A   8015         SJMP      ??CrossCallReturnLabel_41
    782          
    783            // Look through the queue for a message that belongs to the asking task
    784            while ( listHdr != NULL )
    785            {
    786              if ( (listHdr - 1)->dest_id == task_id )
    787              {
    788                if ( foundHdr == NULL )
    789                {
    790                  // Save the first one
    791                  foundHdr = listHdr;
    792                }
    793                else
    794                {
    795                  // Second msg found, stop looking
    796                  break;
    797                }
    798              }
    799              if ( foundHdr == NULL )
   \                     ??osal_msg_receive_0:
   \   00001C   EE           MOV       A,R6
   \   00001D   4F           ORL       A,R7
   \   00001E   7006         JNZ       ??osal_msg_receive_1
    800              {
    801                prevHdr = listHdr;
   \   000020   85....       MOV       ?V4,?V0
   \   000023   85....       MOV       ?V5,?V1
    802              }
    803              listHdr = OSAL_MSG_NEXT( listHdr );
   \                     ??osal_msg_receive_1:
   \   000026   E5..         MOV       A,?V0
   \   000028   24FB         ADD       A,#-0x5
   \   00002A   F582         MOV       DPL,A
   \   00002C   E5..         MOV       A,?V1
   \   00002E   12....       LCALL     ??Subroutine30_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_41:
   \   000031   12....       LCALL     ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_15:
   \   000034   E5..         MOV       A,?V0
   \   000036   45..         ORL       A,?V1
   \   000038   6022         JZ        ??osal_msg_receive_2
   \   00003A   E5..         MOV       A,?V0
   \   00003C   24FF         ADD       A,#-0x1
   \   00003E   F582         MOV       DPL,A
   \   000040   E5..         MOV       A,?V1
   \   000042   12....       LCALL     ??Subroutine30_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_42:
   \   000045   E0           MOVX      A,@DPTR
   \   000046   69           XRL       A,R1
   \   000047   70D3         JNZ       ??osal_msg_receive_0
   \   000049   EE           MOV       A,R6
   \   00004A   4F           ORL       A,R7
   \   00004B   7006         JNZ       ??osal_msg_receive_3
   \   00004D   AE..         MOV       R6,?V0
   \   00004F   AF..         MOV       R7,?V1
   \   000051   80D3         SJMP      ??osal_msg_receive_1
    804            }
    805          
    806            // Is there more than one?
    807            if ( listHdr != NULL )
    808            {
    809              // Yes, Signal the task that a message is waiting
    810              osal_set_event( task_id, SYS_EVENT_MSG );
   \                     ??osal_msg_receive_3:
   \   000053                ; Setup parameters for call to function osal_set_event
   \   000053   7A00         MOV       R2,#0x0
   \   000055   7B80         MOV       R3,#-0x80
   \   000057   12....       LCALL     `??osal_set_event::?relay`; Banked call to: osal_set_event
   \   00005A   800B         SJMP      ??osal_msg_receive_4
    811            }
    812            else
    813            {
    814              // No more
    815              osal_clear_event( task_id, SYS_EVENT_MSG );
   \                     ??osal_msg_receive_2:
   \   00005C                ; Setup parameters for call to function osal_clear_event
   \   00005C   7A00         MOV       R2,#0x0
   \   00005E   7B80         MOV       R3,#-0x80
   \   000060   12....       LCALL     `??osal_clear_event::?relay`; Banked call to: osal_clear_event
    816            }
    817          
    818            // Did we find a message?
    819            if ( foundHdr != NULL )
   \   000063   EE           MOV       A,R6
   \   000064   4F           ORL       A,R7
   \   000065   6015         JZ        ??osal_msg_receive_5
    820            {
    821              // Take out of the link list
    822              osal_msg_extract( &osal_qHead, foundHdr, prevHdr );
   \                     ??osal_msg_receive_4:
   \   000067                ; Setup parameters for call to function osal_msg_extract
   \   000067   78..         MOV       R0,#?V4
   \   000069   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00006C   EE           MOV       A,R6
   \   00006D   FC           MOV       R4,A
   \   00006E   EF           MOV       A,R7
   \   00006F   FD           MOV       R5,A
   \   000070   7A..         MOV       R2,#osal_qHead & 0xff
   \   000072   7B..         MOV       R3,#(osal_qHead >> 8) & 0xff
   \   000074   12....       LCALL     `??osal_msg_extract::?relay`; Banked call to: osal_msg_extract
   \   000077   7402         MOV       A,#0x2
   \   000079   12....       LCALL     ?DEALLOC_XSTACK8
    823            }
    824          
    825            // Release interrupts
    826            HAL_EXIT_CRITICAL_SECTION(intState);
   \                     ??osal_msg_receive_5:
   \   00007C   E5..         MOV       A,?V2
   \   00007E   A2E0         MOV       C,0xE0 /* A   */.0
   \   000080   92AF         MOV       0xa8.7,C
    827          
    828            return ( (uint8*) foundHdr );
   \   000082   EE           MOV       A,R6
   \   000083   FA           MOV       R2,A
   \   000084   EF           MOV       A,R7
   \   000085   FB           MOV       R3,A
   \   000086   7F06         MOV       R7,#0x6
   \   000088   02....       LJMP      ?BANKED_LEAVE_XDATA
   \   00008B                REQUIRE _A_IEN0
    829          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine14:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F5..         MOV       ?V0,A
   \   000003   A3           INC       DPTR
   \   000004   E0           MOVX      A,@DPTR
   \   000005   F5..         MOV       ?V1,A
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine30_0:
   \   000000   34FF         ADDC      A,#-0x1
   \   000002   F583         MOV       DPH,A
   \   000004   22           RET
    830          
    831          /**************************************************************************************************
    832           * @fn          osal_msg_find
    833           *
    834           * @brief       This function finds in place an OSAL message matching the task_id and event
    835           *              parameters.
    836           *
    837           * input parameters
    838           *
    839           * @param       task_id - The OSAL task id that the enqueued OSAL message must match.
    840           * @param       event - The OSAL event id that the enqueued OSAL message must match.
    841           *
    842           * output parameters
    843           *
    844           * None.
    845           *
    846           * @return      NULL if no match, otherwise an in place pointer to the matching OSAL message.
    847           **************************************************************************************************
    848           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    849          osal_event_hdr_t *osal_msg_find(uint8 task_id, uint8 event)
   \                     osal_msg_find:
    850          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   EA           MOV       A,R2
   \   000005   FC           MOV       R4,A
    851            osal_msg_hdr_t *pHdr;
    852            halIntState_t intState;
    853          
    854            HAL_ENTER_CRITICAL_SECTION(intState);  // Hold off interrupts.
   \   000006   A2AF         MOV       C,0xa8.7
   \   000008   E4           CLR       A
   \   000009   33           RLC       A
   \   00000A   F8           MOV       R0,A
   \   00000B   C2AF         CLR       0xa8.7
    855          
    856            pHdr = osal_qHead;  // Point to the top of the queue.
   \   00000D   90....       MOV       DPTR,#osal_qHead
   \   000010   8009         SJMP      ??CrossCallReturnLabel_43
    857          
    858            // Look through the queue for a message that matches the task_id and event parameters.
    859            while (pHdr != NULL)
    860            {
    861              if (((pHdr-1)->dest_id == task_id) && (((osal_event_hdr_t *)pHdr)->event == event))
    862              {
    863                break;
    864              }
    865          
    866              pHdr = OSAL_MSG_NEXT(pHdr);
   \                     ??osal_msg_find_0:
   \   000012   EA           MOV       A,R2
   \   000013   24FB         ADD       A,#-0x5
   \   000015   F582         MOV       DPL,A
   \   000017   EB           MOV       A,R3
   \   000018   12....       LCALL     ??Subroutine30_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_43:
   \   00001B   12....       LCALL     ??Subroutine32_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_61:
   \   00001E   EA           MOV       A,R2
   \   00001F   4B           ORL       A,R3
   \   000020   6015         JZ        ??osal_msg_find_1
   \   000022   EA           MOV       A,R2
   \   000023   24FF         ADD       A,#-0x1
   \   000025   F582         MOV       DPL,A
   \   000027   EB           MOV       A,R3
   \   000028   12....       LCALL     ??Subroutine30_0 & 0xFFFF
    867            }
   \                     ??CrossCallReturnLabel_44:
   \   00002B   E0           MOVX      A,@DPTR
   \   00002C   69           XRL       A,R1
   \   00002D   70E3         JNZ       ??osal_msg_find_0
   \   00002F   8A82         MOV       DPL,R2
   \   000031   8B83         MOV       DPH,R3
   \   000033   E0           MOVX      A,@DPTR
   \   000034   6C           XRL       A,R4
   \   000035   70DB         JNZ       ??osal_msg_find_0
    868          
    869            HAL_EXIT_CRITICAL_SECTION(intState);  // Release interrupts.
   \                     ??osal_msg_find_1:
   \   000037   E8           MOV       A,R0
   \   000038   A2E0         MOV       C,0xE0 /* A   */.0
   \   00003A   92AF         MOV       0xa8.7,C
    870          
    871            return (osal_event_hdr_t *)pHdr;
   \   00003C   02....       LJMP      ?Subroutine0 & 0xFFFF
   \   00003F                REQUIRE _A_IEN0
    872          }
    873          
    874          /**************************************************************************************************
    875           * @fn          osal_msg_count
    876           *
    877           * @brief       This function counts the number of messages, in the OSAL message queue with a
    878           *              a given task ID and message event type.
    879           *
    880           * input parameters
    881           *
    882           * @param       task_id - The OSAL task id that the enqueued OSAL message must match.
    883           * @param       event - The OSAL event id that the enqueued OSAL message must match. 0xFF for 
    884           *              all events.
    885           *
    886           * output parameters
    887           *
    888           * None.
    889           *
    890           * @return      The number of OSAL messages that match the task ID and Event.
    891           **************************************************************************************************
    892           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    893          uint8 osal_msg_count( uint8 task_id, uint8 event )
   \                     osal_msg_count:
    894          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV       A,R1
   \   000006   FB           MOV       R3,A
    895            uint8 count = 0;
   \   000007   7900         MOV       R1,#0x0
    896            osal_msg_hdr_t *pHdr;
    897            halIntState_t intState;
    898          
    899            HAL_ENTER_CRITICAL_SECTION(intState);  // Hold off interrupts.
   \   000009   A2AF         MOV       C,0xa8.7
   \   00000B   E4           CLR       A
   \   00000C   33           RLC       A
   \   00000D   F8           MOV       R0,A
   \   00000E   C2AF         CLR       0xa8.7
    900          
    901            pHdr = osal_qHead;  // Point to the top of the queue.
   \   000010   90....       MOV       DPTR,#osal_qHead
   \   000013   801B         SJMP      ??CrossCallReturnLabel_49
    902          
    903            // Look through the queue for a message that matches the task_id and event parameters.
    904            while (pHdr != NULL)
    905            {
    906              if ( ((pHdr-1)->dest_id == task_id) 
    907                  && ((event == 0xFF) || (((osal_event_hdr_t *)pHdr)->event == event)) )
   \                     ??osal_msg_count_0:
   \   000015   EC           MOV       A,R4
   \   000016   24FF         ADD       A,#-0x1
   \   000018   12....       LCALL     ??Subroutine29_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_47:
   \   00001B   E0           MOVX      A,@DPTR
   \   00001C   6B           XRL       A,R3
   \   00001D   700E         JNZ       ??osal_msg_count_1
   \   00001F   74FF         MOV       A,#-0x1
   \   000021   6A           XRL       A,R2
   \   000022   6008         JZ        ??osal_msg_count_2
   \   000024   8C82         MOV       DPL,R4
   \   000026   8D83         MOV       DPH,R5
   \   000028   E0           MOVX      A,@DPTR
   \   000029   6A           XRL       A,R2
   \   00002A   7001         JNZ       ??osal_msg_count_1
    908              {
    909                count++;
   \                     ??osal_msg_count_2:
   \   00002C   09           INC       R1
    910              }
    911          
    912              pHdr = OSAL_MSG_NEXT(pHdr);
   \                     ??osal_msg_count_1:
   \   00002D   12....       LCALL     ?Subroutine19 & 0xFFFF
    913            }
   \                     ??CrossCallReturnLabel_49:
   \   000030   E0           MOVX      A,@DPTR
   \   000031   FC           MOV       R4,A
   \   000032   A3           INC       DPTR
   \   000033   E0           MOVX      A,@DPTR
   \   000034   FD           MOV       R5,A
   \   000035   EC           MOV       A,R4
   \   000036   4D           ORL       A,R5
   \   000037   70DC         JNZ       ??osal_msg_count_0
    914          
    915            HAL_EXIT_CRITICAL_SECTION(intState);  // Release interrupts.
   \   000039   E8           MOV       A,R0
   \   00003A                REQUIRE ?Subroutine4
   \   00003A                REQUIRE _A_IEN0
   \   00003A                ; // Fall through to label ?Subroutine4
    916          
    917            return ( count );
    918          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   A2E0         MOV       C,0xE0 /* A   */.0
   \   000002                REQUIRE ??Subroutine26_0
   \   000002                ; // Fall through to label ??Subroutine26_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine26_0:
   \   000000   92AF         MOV       0xa8.7,C
   \   000002   80..         SJMP      ??Subroutine27_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine19:
   \   000000   EC           MOV       A,R4
   \   000001   24FB         ADD       A,#-0x5
   \   000003                REQUIRE ??Subroutine29_0
   \   000003                ; // Fall through to label ??Subroutine29_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine29_0:
   \   000000   F582         MOV       DPL,A
   \   000002   ED           MOV       A,R5
   \   000003                REQUIRE ??Subroutine30_0
   \   000003                ; // Fall through to label ??Subroutine30_0
    919          
    920          /*********************************************************************
    921           * @fn      osal_msg_enqueue
    922           *
    923           * @brief
    924           *
    925           *    This function enqueues an OSAL message into an OSAL queue.
    926           *
    927           * @param   osal_msg_q_t *q_ptr - OSAL queue
    928           * @param   void *msg_ptr  - OSAL message
    929           *
    930           * @return  none
    931           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    932          void osal_msg_enqueue( osal_msg_q_t *q_ptr, void *msg_ptr )
   \                     osal_msg_enqueue:
    933          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    934            void *list;
    935            halIntState_t intState;
    936          
    937            // Hold off interrupts
    938            HAL_ENTER_CRITICAL_SECTION(intState);
   \   000005   A2AF         MOV       C,0xa8.7
   \   000007   E4           CLR       A
   \   000008   33           RLC       A
   \   000009   FE           MOV       R6,A
   \   00000A   C2AF         CLR       0xa8.7
    939          
    940            OSAL_MSG_NEXT( msg_ptr ) = NULL;
   \   00000C   12....       LCALL     ?Subroutine19 & 0xFFFF
   \                     ??CrossCallReturnLabel_50:
   \   00000F   E4           CLR       A
   \   000010   F0           MOVX      @DPTR,A
   \   000011   A3           INC       DPTR
   \   000012   12....       LCALL     ??Subroutine28_0 & 0xFFFF
    941            // If first message in queue
    942            if ( *q_ptr == NULL )
   \                     ??CrossCallReturnLabel_40:
   \   000015   800C         SJMP      ??osal_msg_enqueue_0
    943            {
    944              *q_ptr = msg_ptr;
    945            }
    946            else
    947            {
    948              // Find end of queue
    949              for ( list = *q_ptr; OSAL_MSG_NEXT( list ) != NULL; list = OSAL_MSG_NEXT( list ) );
   \                     ??osal_msg_enqueue_1:
   \   000017   12....       LCALL     ?Subroutine23 & 0xFFFF
   \                     ??CrossCallReturnLabel_30:
   \   00001A   F9           MOV       R1,A
   \   00001B   E8           MOV       A,R0
   \   00001C   FA           MOV       R2,A
   \   00001D   E9           MOV       A,R1
   \   00001E   FB           MOV       R3,A
   \   00001F   8882         MOV       DPL,R0
   \   000021   F583         MOV       DPH,A
   \                     ??osal_msg_enqueue_0:
   \   000023   12....       LCALL     ??Subroutine31_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_52:
   \   000026   70EF         JNZ       ??osal_msg_enqueue_1
    950          
    951              // Add message to end of queue
    952              OSAL_MSG_NEXT( list ) = msg_ptr;
   \   000028   8A82         MOV       DPL,R2
   \   00002A   8B83         MOV       DPH,R3
   \   00002C   EC           MOV       A,R4
   \   00002D   F0           MOVX      @DPTR,A
   \   00002E   A3           INC       DPTR
   \   00002F   ED           MOV       A,R5
   \   000030   F0           MOVX      @DPTR,A
    953            }
    954          
    955            // Re-enable interrupts
    956            HAL_EXIT_CRITICAL_SECTION(intState);
   \   000031   EE           MOV       A,R6
   \   000032   80..         SJMP      ?Subroutine4
   \   000034                REQUIRE _A_IEN0
    957          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine23:
   \   000000   E8           MOV       A,R0
   \   000001   24FB         ADD       A,#-0x5
   \   000003   F8           MOV       R0,A
   \   000004   E9           MOV       A,R1
   \   000005   34FF         ADDC      A,#-0x1
   \   000007   22           RET
    958          
    959          /*********************************************************************
    960           * @fn      osal_msg_dequeue
    961           *
    962           * @brief
    963           *
    964           *    This function dequeues an OSAL message from an OSAL queue.
    965           *
    966           * @param   osal_msg_q_t *q_ptr - OSAL queue
    967           *
    968           * @return  void * - pointer to OSAL message or NULL of queue is empty.
    969           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    970          void *osal_msg_dequeue( osal_msg_q_t *q_ptr )
   \                     osal_msg_dequeue:
    971          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FC           MOV       R4,A
   \   000007   EB           MOV       A,R3
   \   000008   FD           MOV       R5,A
    972            void *msg_ptr = NULL;
   \   000009   7A00         MOV       R2,#0x0
   \   00000B   7B00         MOV       R3,#0x0
    973            halIntState_t intState;
    974          
    975            // Hold off interrupts
    976            HAL_ENTER_CRITICAL_SECTION(intState);
   \   00000D   A2AF         MOV       C,0xa8.7
   \   00000F   E4           CLR       A
   \   000010   33           RLC       A
   \   000011   FE           MOV       R6,A
   \   000012   C2AF         CLR       0xa8.7
    977          
    978            if ( *q_ptr != NULL )
   \   000014   8C82         MOV       DPL,R4
   \   000016   8D83         MOV       DPH,R5
   \   000018   12....       LCALL     ??Subroutine31_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_53:
   \   00001B   602E         JZ        ??osal_msg_dequeue_0
    979            {
    980              // Dequeue message
    981              msg_ptr = *q_ptr;
   \   00001D   E8           MOV       A,R0
   \   00001E   FA           MOV       R2,A
   \   00001F   E9           MOV       A,R1
   \   000020   FB           MOV       R3,A
    982              *q_ptr = OSAL_MSG_NEXT( msg_ptr );
   \   000021   12....       LCALL     ?Subroutine23 & 0xFFFF
   \                     ??CrossCallReturnLabel_31:
   \   000024   F9           MOV       R1,A
   \   000025   8882         MOV       DPL,R0
   \   000027   F583         MOV       DPH,A
   \   000029   12....       LCALL     ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_16:
   \   00002C   8C82         MOV       DPL,R4
   \   00002E   8D83         MOV       DPH,R5
   \   000030   E5..         MOV       A,?V0
   \   000032   F0           MOVX      @DPTR,A
   \   000033   A3           INC       DPTR
   \   000034   E5..         MOV       A,?V1
   \   000036   F0           MOVX      @DPTR,A
    983              OSAL_MSG_NEXT( msg_ptr ) = NULL;
   \   000037   8882         MOV       DPL,R0
   \   000039   8983         MOV       DPH,R1
   \   00003B   E4           CLR       A
   \   00003C   F0           MOVX      @DPTR,A
   \   00003D   A3           INC       DPTR
   \   00003E   F0           MOVX      @DPTR,A
    984              OSAL_MSG_ID( msg_ptr ) = TASK_NO_TASK;
   \   00003F   EA           MOV       A,R2
   \   000040   24FF         ADD       A,#-0x1
   \   000042   F582         MOV       DPL,A
   \   000044   EB           MOV       A,R3
   \   000045   12....       LCALL     ??Subroutine30_0 & 0xFFFF
    985            }
   \                     ??CrossCallReturnLabel_45:
   \   000048   74FF         MOV       A,#-0x1
   \   00004A   F0           MOVX      @DPTR,A
    986          
    987            // Re-enable interrupts
    988            HAL_EXIT_CRITICAL_SECTION(intState);
   \                     ??osal_msg_dequeue_0:
   \   00004B   EE           MOV       A,R6
   \   00004C   A2E0         MOV       C,0xE0 /* A   */.0
   \   00004E   92AF         MOV       0xa8.7,C
    989          
    990            return msg_ptr;
   \   000050                REQUIRE ?Subroutine2
   \   000050                REQUIRE _A_IEN0
   \   000050                ; // Fall through to label ?Subroutine2
    991          }
    992          
    993          /*********************************************************************
    994           * @fn      osal_msg_push
    995           *
    996           * @brief
    997           *
    998           *    This function pushes an OSAL message to the head of an OSAL
    999           *    queue.
   1000           *
   1001           * @param   osal_msg_q_t *q_ptr - OSAL queue
   1002           * @param   void *msg_ptr  - OSAL message
   1003           *
   1004           * @return  none
   1005           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1006          void osal_msg_push( osal_msg_q_t *q_ptr, void *msg_ptr )
   \                     osal_msg_push:
   1007          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   1008            halIntState_t intState;
   1009          
   1010            // Hold off interrupts
   1011            HAL_ENTER_CRITICAL_SECTION(intState);
   \   000005   A8A8         MOV       R0,0xa8+0x0
   \   000007   C2AF         CLR       0xa8.7
   1012          
   1013            // Push message to head of queue
   1014            OSAL_MSG_NEXT( msg_ptr ) = *q_ptr;
   \   000009   8A82         MOV       DPL,R2
   \   00000B   8B83         MOV       DPH,R3
   \   00000D   E0           MOVX      A,@DPTR
   \   00000E   FE           MOV       R6,A
   \   00000F   A3           INC       DPTR
   \   000010   E0           MOVX      A,@DPTR
   \   000011   FF           MOV       R7,A
   \   000012   12....       LCALL     ?Subroutine19 & 0xFFFF
   \                     ??CrossCallReturnLabel_51:
   \   000015   12....       LCALL     ?Subroutine20 & 0xFFFF
   1015            *q_ptr = msg_ptr;
   \                     ??CrossCallReturnLabel_38:
   \   000018   EC           MOV       A,R4
   \   000019   F0           MOVX      @DPTR,A
   \   00001A   A3           INC       DPTR
   \   00001B   ED           MOV       A,R5
   \   00001C   F0           MOVX      @DPTR,A
   1016          
   1017            // Re-enable interrupts
   1018            HAL_EXIT_CRITICAL_SECTION(intState);
   \   00001D   E8           MOV       A,R0
   \   00001E   A2E7         MOV       C,0xE0 /* A   */.7
   \   000020   02....       LJMP      ??Subroutine26_0 & 0xFFFF
   \   000023                REQUIRE _A_IEN0
   1019          }
   1020          
   1021          /*********************************************************************
   1022           * @fn      osal_msg_extract
   1023           *
   1024           * @brief
   1025           *
   1026           *    This function extracts and removes an OSAL message from the
   1027           *    middle of an OSAL queue.
   1028           *
   1029           * @param   osal_msg_q_t *q_ptr - OSAL queue
   1030           * @param   void *msg_ptr  - OSAL message to be extracted
   1031           * @param   void *prev_ptr  - OSAL message before msg_ptr in queue
   1032           *
   1033           * @return  none
   1034           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1035          void osal_msg_extract( osal_msg_q_t *q_ptr, void *msg_ptr, void *prev_ptr )
   \                     osal_msg_extract:
   1036          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000   74F5         MOV       A,#-0xb
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 0
   1037            halIntState_t intState;
   1038          
   1039            // Hold off interrupts
   1040            HAL_ENTER_CRITICAL_SECTION(intState);
   \   000005   A2AF         MOV       C,0xa8.7
   \   000007   E4           CLR       A
   \   000008   33           RLC       A
   \   000009   F5..         MOV       ?V2,A
   \   00000B   C2AF         CLR       0xa8.7
   1041          
   1042            if ( msg_ptr == *q_ptr )
   \   00000D   EC           MOV       A,R4
   \   00000E   24FB         ADD       A,#-0x5
   \   000010   F8           MOV       R0,A
   \   000011   ED           MOV       A,R5
   \   000012   34FF         ADDC      A,#-0x1
   \   000014   F9           MOV       R1,A
   \   000015   E8           MOV       A,R0
   \   000016   FE           MOV       R6,A
   \   000017   E9           MOV       A,R1
   \   000018   FF           MOV       R7,A
   \   000019   8882         MOV       DPL,R0
   \   00001B   F583         MOV       DPH,A
   \   00001D   E0           MOVX      A,@DPTR
   \   00001E   F8           MOV       R0,A
   \   00001F   A3           INC       DPTR
   \   000020   E0           MOVX      A,@DPTR
   \   000021   F9           MOV       R1,A
   \   000022   8A82         MOV       DPL,R2
   \   000024   8B83         MOV       DPH,R3
   \   000026   12....       LCALL     ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_17:
   \   000029   EC           MOV       A,R4
   \   00002A   65..         XRL       A,?V0
   \   00002C   7003         JNZ       ??osal_msg_extract_0
   \   00002E   ED           MOV       A,R5
   \   00002F   65..         XRL       A,?V1
   \                     ??osal_msg_extract_0:
   \   000031   7006         JNZ       ??osal_msg_extract_1
   1043            {
   1044              // remove from first
   1045              *q_ptr = OSAL_MSG_NEXT( msg_ptr );
   \   000033   8A82         MOV       DPL,R2
   \   000035   8B83         MOV       DPH,R3
   \   000037   8012         SJMP      ??CrossCallReturnLabel_46
   1046            }
   1047            else
   1048            {
   1049              // remove from middle
   1050              OSAL_MSG_NEXT( prev_ptr ) = OSAL_MSG_NEXT( msg_ptr );
   \                     ??osal_msg_extract_1:
   \   000039   740B         MOV       A,#0xb
   \   00003B   12....       LCALL     ?XSTACK_DISP0_8
   \   00003E   E0           MOVX      A,@DPTR
   \   00003F   FA           MOV       R2,A
   \   000040   A3           INC       DPTR
   \   000041   E0           MOVX      A,@DPTR
   \   000042   CA           XCH       A,R2
   \   000043   24FB         ADD       A,#-0x5
   \   000045   F582         MOV       DPL,A
   \   000047   EA           MOV       A,R2
   \   000048   12....       LCALL     ??Subroutine30_0 & 0xFFFF
   1051            }
   \                     ??CrossCallReturnLabel_46:
   \   00004B   E8           MOV       A,R0
   \   00004C   F0           MOVX      @DPTR,A
   \   00004D   A3           INC       DPTR
   \   00004E   E9           MOV       A,R1
   \   00004F   F0           MOVX      @DPTR,A
   1052            OSAL_MSG_NEXT( msg_ptr ) = NULL;
   \   000050   8E82         MOV       DPL,R6
   \   000052   8F83         MOV       DPH,R7
   \   000054   E4           CLR       A
   \   000055   F0           MOVX      @DPTR,A
   \   000056   A3           INC       DPTR
   \   000057   F0           MOVX      @DPTR,A
   1053            OSAL_MSG_ID( msg_ptr ) = TASK_NO_TASK;
   \   000058   EC           MOV       A,R4
   \   000059   24FF         ADD       A,#-0x1
   \   00005B   12....       LCALL     ??Subroutine29_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_48:
   \   00005E   74FF         MOV       A,#-0x1
   \   000060   F0           MOVX      @DPTR,A
   1054          
   1055            // Re-enable interrupts
   1056            HAL_EXIT_CRITICAL_SECTION(intState);
   \   000061   E5..         MOV       A,?V2
   \   000063   A2E0         MOV       C,0xE0 /* A   */.0
   \   000065   92AF         MOV       0xa8.7,C
   1057          }
   \   000067   7F03         MOV       R7,#0x3
   \   000069   02....       LJMP      ?BANKED_LEAVE_XDATA
   \   00006C                REQUIRE _A_IEN0
   1058          
   1059          /*********************************************************************
   1060           * @fn      osal_msg_enqueue_max
   1061           *
   1062           * @brief
   1063           *
   1064           *    This function enqueues an OSAL message into an OSAL queue if
   1065           *    the length of the queue is less than max.
   1066           *
   1067           * @param   osal_msg_q_t *q_ptr - OSAL queue
   1068           * @param   void *msg_ptr  - OSAL message
   1069           * @param   uint8 max - maximum length of queue
   1070           *
   1071           * @return  TRUE if message was enqueued, FALSE otherwise
   1072           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1073          uint8 osal_msg_enqueue_max( osal_msg_q_t *q_ptr, void *msg_ptr, uint8 max )
   \                     osal_msg_enqueue_max:
   1074          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV       ?V0,R2
   \   000007   8B..         MOV       ?V1,R3
   \   000009   E9           MOV       A,R1
   \   00000A   FE           MOV       R6,A
   1075            void *list;
   1076            uint8 ret = FALSE;
   \   00000B   7A00         MOV       R2,#0x0
   1077            halIntState_t intState;
   1078          
   1079            // Hold off interrupts
   1080            HAL_ENTER_CRITICAL_SECTION(intState);
   \   00000D   A2AF         MOV       C,0xa8.7
   \   00000F   E4           CLR       A
   \   000010   33           RLC       A
   \   000011   FB           MOV       R3,A
   \   000012   C2AF         CLR       0xa8.7
   1081          
   1082            // If first message in queue
   1083            if ( *q_ptr == NULL )
   \   000014   85..82       MOV       DPL,?V0
   \   000017   85..83       MOV       DPH,?V1
   \   00001A   12....       LCALL     ??Subroutine31_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_54:
   \   00001D   7005         JNZ       ??osal_msg_enqueue_max_0
   1084            {
   1085              *q_ptr = msg_ptr;
   \   00001F   8015         SJMP      ??osal_msg_enqueue_max_1
   1086              ret = TRUE;
   1087            }
   1088            else
   1089            {
   1090              // Find end of queue or max
   1091              list = *q_ptr;
   1092              max--;
   1093              while ( (OSAL_MSG_NEXT( list ) != NULL) && (max > 0) )
   \                     ??osal_msg_enqueue_max_2:
   \   000021   EE           MOV       A,R6
   \   000022   601F         JZ        ??osal_msg_enqueue_max_3
   1094              {
   1095                list = OSAL_MSG_NEXT( list );
   1096                max--;
   \                     ??osal_msg_enqueue_max_0:
   \   000024   1E           DEC       R6
   1097              }
   \   000025   12....       LCALL     ?Subroutine23 & 0xFFFF
   \                     ??CrossCallReturnLabel_32:
   \   000028   88..         MOV       ?V0,R0
   \   00002A   F5..         MOV       ?V1,A
   \   00002C   8882         MOV       DPL,R0
   \   00002E   12....       LCALL     ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_56:
   \   000031   70EE         JNZ       ??osal_msg_enqueue_max_2
   1098          
   1099              // Add message to end of queue if max not reached
   1100              if ( max != 0 )
   \   000033   EE           MOV       A,R6
   \   000034   600D         JZ        ??osal_msg_enqueue_max_3
   1101              {
   1102                OSAL_MSG_NEXT( list ) = msg_ptr;
   \                     ??osal_msg_enqueue_max_1:
   \   000036   85..82       MOV       DPL,?V0
   \   000039   85..83       MOV       DPH,?V1
   \   00003C   EC           MOV       A,R4
   \   00003D   F0           MOVX      @DPTR,A
   \   00003E   A3           INC       DPTR
   \   00003F   ED           MOV       A,R5
   \   000040   F0           MOVX      @DPTR,A
   1103                ret = TRUE;
   \   000041   7A01         MOV       R2,#0x1
   1104              }
   1105            }
   1106          
   1107            // Re-enable interrupts
   1108            HAL_EXIT_CRITICAL_SECTION(intState);
   \                     ??osal_msg_enqueue_max_3:
   \   000043   EB           MOV       A,R3
   \   000044   A2E0         MOV       C,0xE0 /* A   */.0
   \   000046   92AF         MOV       0xa8.7,C
   1109          
   1110            return ret;
   \   000048   EA           MOV       A,R2
   \   000049   F9           MOV       R1,A
   \   00004A   02....       LJMP      ?Subroutine2 & 0xFFFF
   \   00004D                REQUIRE _A_IEN0
   1111          }
   1112          
   1113          /*********************************************************************
   1114           * @fn      osal_set_event
   1115           *
   1116           * @brief
   1117           *
   1118           *    This function is called to set the event flags for a task. The
   1119           *    event passed in is OR'd into the task's event variable.
   1120           *
   1121           * @param   uint8 task_id - receiving tasks ID
   1122           * @param   uint8 event_flag - what event to set
   1123           *
   1124           * @return  SUCCESS, MSG_BUFFER_NOT_AVAIL, FAILURE, INVALID_TASK
   1125           */
   1126          #ifdef OSAL_PORT2TIRTOS
   1127          uint8 osal_set_event_raw( uint8 task_id, uint16 event_flag )
   1128          #else /* OSAL_PORT2TIRTOS */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1129          uint8 osal_set_event( uint8 task_id, uint16 event_flag )
   \                     osal_set_event:
   1130          #endif /* OSAL_PORT2TIRTOS */
   1131          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   1132          #ifdef USE_ICALL
   1133            if (task_id & OSAL_PROXY_ID_FLAG)
   1134            {
   1135              /* Destination is a proxy task */
   1136              osal_msg_hdr_t *hdr;
   1137              ICall_EntityID src, dst;
   1138              uint8 taskid;
   1139          
   1140              struct _osal_event_msg_t
   1141              {
   1142                uint16 signature;
   1143                uint16 event_flag;
   1144              } *msg_ptr = (struct _osal_event_msg_t *)
   1145                osal_msg_allocate(sizeof(*msg_ptr));
   1146          
   1147              if (!msg_ptr)
   1148              {
   1149                return MSG_BUFFER_NOT_AVAIL;
   1150              }
   1151              msg_ptr->signature = 0xffffu;
   1152              msg_ptr->event_flag = event_flag;
   1153              hdr = (osal_msg_hdr_t *)msg_ptr - 1;
   1154          
   1155              taskid = osal_self();
   1156              if (taskid == TASK_NO_TASK)
   1157              {
   1158                /* Call must have been made from either an ISR or a user-thread */
   1159                src = osal_notask_entity;
   1160              }
   1161              else
   1162              {
   1163                src = (ICall_EntityID) osal_dispatch_entities[taskid + tasksCnt];
   1164              }
   1165          
   1166              if (src == OSAL_INVALID_DISPATCH_ID)
   1167              {
   1168                /* The source entity is not registered */
   1169                osal_msg_deallocate((uint8 *) msg_ptr);
   1170                ICall_abort();
   1171                return FAILURE;
   1172              }
   1173              dst = osal_proxy2alien(task_id);
   1174              hdr->dest_id = TASK_NO_TASK;
   1175              if (ICall_send(src, dst,
   1176                             ICALL_MSG_FORMAT_KEEP, msg_ptr) ==
   1177                  ICALL_ERRNO_SUCCESS)
   1178              {
   1179                return SUCCESS;
   1180              }
   1181              osal_msg_deallocate((uint8 *) msg_ptr);
   1182              return FAILURE;
   1183            }
   1184          #endif /* USE_ICALL */
   1185          
   1186            if ( task_id < tasksCnt )
   \   000005   90....       MOV       DPTR,#tasksCnt
   \   000008   E0           MOVX      A,@DPTR
   \   000009   F8           MOV       R0,A
   \   00000A   E9           MOV       A,R1
   \   00000B   C3           CLR       C
   \   00000C   98           SUBB      A,R0
   \   00000D   5027         JNC       ??osal_set_event_0
   1187            {
   1188              halIntState_t   intState;
   1189              HAL_ENTER_CRITICAL_SECTION(intState);    // Hold off interrupts
   \   00000F   ACA8         MOV       R4,0xa8+0x0
   \   000011   C2AF         CLR       0xa8.7
   1190              tasksEvents[task_id] |= event_flag;  // Stuff the event bit(s)
   \   000013   E9           MOV       A,R1
   \   000014   29           ADD       A,R1
   \   000015   F8           MOV       R0,A
   \   000016   E4           CLR       A
   \   000017   33           RLC       A
   \   000018   F9           MOV       R1,A
   \   000019   90....       MOV       DPTR,#tasksEvents
   \   00001C   E0           MOVX      A,@DPTR
   \   00001D   28           ADD       A,R0
   \   00001E   FD           MOV       R5,A
   \   00001F   A3           INC       DPTR
   \   000020   E0           MOVX      A,@DPTR
   \   000021   39           ADDC      A,R1
   \   000022   8D82         MOV       DPL,R5
   \   000024   F583         MOV       DPH,A
   \   000026   E0           MOVX      A,@DPTR
   \   000027   4A           ORL       A,R2
   \   000028   F0           MOVX      @DPTR,A
   \   000029   A3           INC       DPTR
   \   00002A   E0           MOVX      A,@DPTR
   \   00002B   4B           ORL       A,R3
   \   00002C   F0           MOVX      @DPTR,A
   1191              HAL_EXIT_CRITICAL_SECTION(intState);     // Release interrupts
   \   00002D   EC           MOV       A,R4
   \   00002E   A2E7         MOV       C,0xE0 /* A   */.7
   \   000030   92AF         MOV       0xa8.7,C
   1192          #ifdef USE_ICALL
   1193              ICall_signal(osal_semaphore);
   1194          #endif /* USE_ICALL */
   1195              return ( SUCCESS );
   \   000032   7900         MOV       R1,#0x0
   \   000034   8002         SJMP      ??osal_set_event_1
   1196            }
   1197             else
   1198            {
   1199              return ( INVALID_TASK );
   \                     ??osal_set_event_0:
   \   000036   7903         MOV       R1,#0x3
   1200            }
   \                     ??osal_set_event_1:
   \   000038   02....       LJMP      ??Subroutine27_0 & 0xFFFF
   \   00003B                REQUIRE _A_IEN0
   1201          }
   1202          
   1203          /*********************************************************************
   1204           * @fn      osal_clear_event
   1205           *
   1206           * @brief
   1207           *
   1208           *    This function is called to clear the event flags for a task. The
   1209           *    event passed in is masked out of the task's event variable.
   1210           *
   1211           * @param   uint8 task_id - receiving tasks ID
   1212           * @param   uint8 event_flag - what event to clear
   1213           *
   1214           * @return  SUCCESS, INVALID_TASK
   1215           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1216          uint8 osal_clear_event( uint8 task_id, uint16 event_flag )
   \                     osal_clear_event:
   1217          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   1218            if ( task_id < tasksCnt )
   \   000005   90....       MOV       DPTR,#tasksCnt
   \   000008   E0           MOVX      A,@DPTR
   \   000009   F8           MOV       R0,A
   \   00000A   E9           MOV       A,R1
   \   00000B   C3           CLR       C
   \   00000C   98           SUBB      A,R0
   \   00000D   5021         JNC       ??osal_clear_event_0
   1219            {
   1220              halIntState_t   intState;
   1221              HAL_ENTER_CRITICAL_SECTION(intState);    // Hold off interrupts
   \   00000F   AEA8         MOV       R6,0xa8+0x0
   \   000011   C2AF         CLR       0xa8.7
   1222              tasksEvents[task_id] &= ~(event_flag);   // Clear the event bit(s)
   \   000013   EA           MOV       A,R2
   \   000014   F4           CPL       A
   \   000015   FC           MOV       R4,A
   \   000016   EB           MOV       A,R3
   \   000017   F4           CPL       A
   \   000018   FD           MOV       R5,A
   \   000019   E9           MOV       A,R1
   \   00001A   29           ADD       A,R1
   \   00001B   12....       LCALL     ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_22:
   \   00001E   F583         MOV       DPH,A
   \   000020   E0           MOVX      A,@DPTR
   \   000021   5C           ANL       A,R4
   \   000022   F0           MOVX      @DPTR,A
   \   000023   A3           INC       DPTR
   \   000024   E0           MOVX      A,@DPTR
   \   000025   5D           ANL       A,R5
   \   000026   F0           MOVX      @DPTR,A
   1223              HAL_EXIT_CRITICAL_SECTION(intState);     // Release interrupts
   \   000027   EE           MOV       A,R6
   \   000028   A2E7         MOV       C,0xE0 /* A   */.7
   \   00002A   92AF         MOV       0xa8.7,C
   1224              return ( SUCCESS );
   \   00002C   7900         MOV       R1,#0x0
   \   00002E   8002         SJMP      ??osal_clear_event_1
   1225            }
   1226             else
   1227            {
   1228              return ( INVALID_TASK );
   \                     ??osal_clear_event_0:
   \   000030   7903         MOV       R1,#0x3
   1229            }
   \                     ??osal_clear_event_1:
   \   000032   02....       LJMP      ??Subroutine27_0 & 0xFFFF
   \   000035                REQUIRE _A_IEN0
   1230          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine17:
   \   000000   F8           MOV       R0,A
   \   000001   E4           CLR       A
   \   000002   33           RLC       A
   \   000003   F9           MOV       R1,A
   \   000004   90....       MOV       DPTR,#tasksEvents
   \   000007   E0           MOVX      A,@DPTR
   \   000008   28           ADD       A,R0
   \   000009   FA           MOV       R2,A
   \   00000A   A3           INC       DPTR
   \   00000B   E0           MOVX      A,@DPTR
   \   00000C   39           ADDC      A,R1
   \   00000D   8A82         MOV       DPL,R2
   \   00000F   22           RET
   1231          
   1232          /*********************************************************************
   1233           * @fn      osal_isr_register
   1234           *
   1235           * @brief
   1236           *
   1237           *   This function is called to register a service routine with an
   1238           *   interrupt. When the interrupt occurs, this service routine is called.
   1239           *
   1240           * @param   uint8 interrupt_id - Interrupt number
   1241           * @param   void (*isr_ptr)( uint8* ) - function pointer to ISR
   1242           *
   1243           * @return  SUCCESS, INVALID_INTERRUPT_ID,
   1244           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1245          uint8 osal_isr_register( uint8 interrupt_id, void (*isr_ptr)( uint8* ) )
   \                     osal_isr_register:
   1246          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1247            // Remove these statements when functionality is complete
   1248            (void)interrupt_id;
   1249            (void)isr_ptr;
   1250            return ( SUCCESS );
   \   000000   7900         MOV       R1,#0x0
   \   000002   02....       LJMP      ?BRET
   1251          }
   1252          
   1253          /*********************************************************************
   1254           * @fn      osal_int_enable
   1255           *
   1256           * @brief
   1257           *
   1258           *   This function is called to enable an interrupt. Once enabled,
   1259           *   occurrence of the interrupt causes the service routine associated
   1260           *   with that interrupt to be called.
   1261           *
   1262           *   If INTS_ALL is the interrupt_id, interrupts (in general) are enabled.
   1263           *   If a single interrupt is passed in, then interrupts still have
   1264           *   to be enabled with another call to INTS_ALL.
   1265           *
   1266           * @param   uint8 interrupt_id - Interrupt number
   1267           *
   1268           * @return  SUCCESS or INVALID_INTERRUPT_ID
   1269           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1270          uint8 osal_int_enable( uint8 interrupt_id )
   \                     osal_int_enable:
   1271          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   \   000000   E9           MOV       A,R1
   \   000001   F8           MOV       R0,A
   1272          
   1273            if ( interrupt_id == INTS_ALL )
   \   000002   74FF         MOV       A,#-0x1
   \   000004   68           XRL       A,R0
   \   000005   7006         JNZ       ??osal_int_enable_0
   1274            {
   1275              HAL_ENABLE_INTERRUPTS();
   \   000007   D2AF         SETB      0xa8.7
   1276              return ( SUCCESS );
   \   000009   7900         MOV       R1,#0x0
   \   00000B   8002         SJMP      ??osal_int_enable_1
   1277            }
   1278            else
   1279            {
   1280              return ( INVALID_INTERRUPT_ID );
   \                     ??osal_int_enable_0:
   \   00000D   7907         MOV       R1,#0x7
   \                     ??osal_int_enable_1:
   \   00000F   02....       LJMP      ?BRET
   \   000012                REQUIRE _A_IEN0
   1281            }
   1282          }
   1283          
   1284          /*********************************************************************
   1285           * @fn      osal_int_disable
   1286           *
   1287           * @brief
   1288           *
   1289           *   This function is called to disable an interrupt. When a disabled
   1290           *   interrupt occurs, the service routine associated with that
   1291           *   interrupt is not called.
   1292           *
   1293           *   If INTS_ALL is the interrupt_id, interrupts (in general) are disabled.
   1294           *   If a single interrupt is passed in, then just that interrupt is disabled.
   1295           *
   1296           * @param   uint8 interrupt_id - Interrupt number
   1297           *
   1298           * @return  SUCCESS or INVALID_INTERRUPT_ID
   1299           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1300          uint8 osal_int_disable( uint8 interrupt_id )
   \                     osal_int_disable:
   1301          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   \   000000   E9           MOV       A,R1
   \   000001   F8           MOV       R0,A
   1302          
   1303            if ( interrupt_id == INTS_ALL )
   \   000002   74FF         MOV       A,#-0x1
   \   000004   68           XRL       A,R0
   \   000005   7006         JNZ       ??osal_int_disable_0
   1304            {
   1305              HAL_DISABLE_INTERRUPTS();
   \   000007   C2AF         CLR       0xa8.7
   1306              return ( SUCCESS );
   \   000009   7900         MOV       R1,#0x0
   \   00000B   8002         SJMP      ??osal_int_disable_1
   1307            }
   1308            else
   1309            {
   1310              return ( INVALID_INTERRUPT_ID );
   \                     ??osal_int_disable_0:
   \   00000D   7907         MOV       R1,#0x7
   \                     ??osal_int_disable_1:
   \   00000F   02....       LJMP      ?BRET
   \   000012                REQUIRE _A_IEN0
   1311            }
   1312          }
   1313          
   1314          /*********************************************************************
   1315           * @fn      osal_init_system
   1316           *
   1317           * @brief
   1318           *
   1319           *   This function initializes the "task" system by creating the
   1320           *   tasks defined in the task table (OSAL_Tasks.h).
   1321           *
   1322           * @param   void
   1323           *
   1324           * @return  SUCCESS
   1325           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1326          uint8 osal_init_system( void )
   \                     osal_init_system:
   1327          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1328          #if !defined USE_ICALL && !defined OSAL_PORT2TIRTOS
   1329            // Initialize the Memory Allocation System
   1330            osal_mem_init();
   \   000004                ; Setup parameters for call to function osal_mem_init
   \   000004   12....       LCALL     `??osal_mem_init::?relay`; Banked call to: osal_mem_init
   1331          #endif /* !defined USE_ICALL && !defined OSAL_PORT2TIRTOS */
   1332          
   1333            // Initialize the message queue
   1334            osal_qHead = NULL;
   \   000007   90....       MOV       DPTR,#osal_qHead
   \   00000A   E4           CLR       A
   \   00000B   F0           MOVX      @DPTR,A
   \   00000C   A3           INC       DPTR
   \   00000D   F0           MOVX      @DPTR,A
   1335          
   1336            // Initialize the timers
   1337            osalTimerInit();
   \   00000E                ; Setup parameters for call to function osalTimerInit
   \   00000E   12....       LCALL     `??osalTimerInit::?relay`; Banked call to: osalTimerInit
   1338          
   1339            // Initialize the Power Management System
   1340            osal_pwrmgr_init();
   \   000011                ; Setup parameters for call to function osal_pwrmgr_init
   \   000011   12....       LCALL     `??osal_pwrmgr_init::?relay`; Banked call to: osal_pwrmgr_init
   1341          
   1342          #ifdef USE_ICALL
   1343            /* Prepare memory space for service enrollment */
   1344            osal_prepare_svc_enroll();
   1345          #endif /* USE_ICALL */
   1346          
   1347            // Initialize the system tasks.
   1348            osalInitTasks();
   \   000014                ; Setup parameters for call to function osalInitTasks
   \   000014   12....       LCALL     `??osalInitTasks::?relay`; Banked call to: osalInitTasks
   1349          
   1350          #if !defined USE_ICALL && !defined OSAL_PORT2TIRTOS
   1351            // Setup efficient search for the first free block of heap.
   1352            osal_mem_kick();
   \   000017                ; Setup parameters for call to function osal_mem_kick
   \   000017   12....       LCALL     `??osal_mem_kick::?relay`; Banked call to: osal_mem_kick
   1353          #endif /* !defined USE_ICALL && !defined OSAL_PORT2TIRTOS */
   1354          
   1355          #ifdef USE_ICALL
   1356            // Initialize variables used to track timing and provide OSAL timer service
   1357            osal_last_timestamp = (uint_least32_t) ICall_getTicks();
   1358            osal_tickperiod = (uint_least32_t) ICall_getTickPeriod();
   1359            osal_max_msecs = (uint_least32_t) ICall_getMaxMSecs();
   1360            /* Reduce ceiling considering potential latency */
   1361            osal_max_msecs -= 2;
   1362          #endif /* USE_ICALL */
   1363          
   1364            return ( SUCCESS );
   \   00001A   7900         MOV       R1,#0x0
   \   00001C   02....       LJMP      ?Subroutine0 & 0xFFFF
   1365          }
   1366          
   1367          /*********************************************************************
   1368           * @fn      osal_start_system
   1369           *
   1370           * @brief
   1371           *
   1372           *   This function is the main loop function of the task system (if
   1373           *   ZBIT and UBIT are not defined). This Function doesn't return.
   1374           *
   1375           * @param   void
   1376           *
   1377           * @return  none
   1378           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1379          void osal_start_system( void )
   \                     osal_start_system:
   1380          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1381          #ifdef USE_ICALL
   1382            /* Kick off timer service in order to allocate resources upfront.
   1383             * The first timeout is required to schedule next OSAL timer event
   1384             * as well. */
   1385            ICall_Errno errno = ICall_setTimer(1, osal_msec_timer_cback,
   1386                                               (void *) osal_msec_timer_seq,
   1387                                               &osal_timerid_msec_timer);
   1388            if (errno != ICALL_ERRNO_SUCCESS)
   1389            {
   1390              ICall_abort();
   1391            }
   1392          #endif /* USE_ICALL */
   1393          
   1394          #if !defined ( ZBIT ) && !defined ( UBIT )
   1395            for(;;)  // Forever Loop
   1396          #endif
   1397            {
   1398              osal_run_system();
   \                     ??osal_start_system_0:
   \   000004                ; Setup parameters for call to function osal_run_system
   \   000004   12....       LCALL     `??osal_run_system::?relay`; Banked call to: osal_run_system
   1399          
   1400          #ifdef WDT_IN_PM1
   1401              WatchDogClear();
   \   000007   E5C9         MOV       A,0xc9
   \   000009   540F         ANL       A,#0xf
   \   00000B   44A0         ORL       A,#0xa0
   \   00000D   F5C9         MOV       0xc9,A
   \   00000F   E5C9         MOV       A,0xc9
   \   000011   540F         ANL       A,#0xf
   \   000013   4450         ORL       A,#0x50
   \   000015   F5C9         MOV       0xc9,A
   \   000017   80EB         SJMP      ??osal_start_system_0
   \   000019                REQUIRE WDCTL
   1402          #endif
   1403          
   1404          #ifdef USE_ICALL
   1405              ICall_wait(ICALL_TIMEOUT_FOREVER);
   1406          #endif /* USE_ICALL */
   1407            }
   1408          }
   1409          
   1410          #ifdef USE_ICALL
   1411          /*********************************************************************
   1412           * @fn      osal_alien2proxy
   1413           *
   1414           * @brief
   1415           *
   1416           *   Assign or retrieve a proxy OSAL task id for an external ICall entity.
   1417           *
   1418           * @param   origid  ICall entity id
   1419           *
   1420           * @return  proxy OSAL task id
   1421           */
   1422          static uint8 osal_alien2proxy(ICall_EntityID origid)
   1423          {
   1424            size_t i;
   1425          
   1426            for (i = 0; i < OSAL_MAX_NUM_PROXY_TASKS; i++)
   1427            {
   1428              if (osal_proxy_tasks[i] == OSAL_INVALID_DISPATCH_ID)
   1429              {
   1430                /* proxy not found. Create a new one */
   1431                osal_proxy_tasks[i] = (uint8) origid;
   1432                return (OSAL_PROXY_ID_FLAG | i);
   1433              }
   1434              else if ((ICall_EntityID) osal_proxy_tasks[i] == origid)
   1435              {
   1436                return (OSAL_PROXY_ID_FLAG | i);
   1437              }
   1438            }
   1439            /* abort */
   1440            ICall_abort();
   1441            return TASK_NO_TASK;
   1442          }
   1443          
   1444          /*********************************************************************
   1445           * @fn      osal_proxy2alien
   1446           *
   1447           * @brief
   1448           *
   1449           *   Retrieve the ICall entity id for a proxy OSAL task id
   1450           *
   1451           * @param   proxyid  Proxy OSAL task id
   1452           *
   1453           * @return  ICall entity id
   1454           */
   1455          static ICall_EntityID osal_proxy2alien(uint8 proxyid)
   1456          {
   1457            proxyid ^= OSAL_PROXY_ID_FLAG;
   1458            if (proxyid >= OSAL_MAX_NUM_PROXY_TASKS)
   1459            {
   1460              /* abort */
   1461              ICall_abort();
   1462            }
   1463            return (ICall_EntityID) osal_proxy_tasks[proxyid];
   1464          }
   1465          
   1466          /*********************************************************************
   1467           * @fn      osal_dispatch2id
   1468           *
   1469           * @brief
   1470           *
   1471           *   Retrieve OSAL task id mapped to a designated ICall entity id
   1472           *
   1473           * @param   entity  ICall entity id
   1474           *
   1475           * @return  OSAL task id
   1476           */
   1477          static uint8 osal_dispatch2id(ICall_EntityID entity)
   1478          {
   1479            size_t i;
   1480          
   1481            for (i = 0; i < tasksCnt; i++)
   1482            {
   1483              if ((ICall_EntityID) osal_dispatch_entities[i] == entity)
   1484              {
   1485                return i;
   1486              }
   1487            }
   1488            return TASK_NO_TASK;
   1489          }
   1490          
   1491          /*********************************************************************
   1492           * @fn      osal_msec_timer_cback
   1493           *
   1494           * @brief
   1495           *
   1496           *   This function is a callback function for ICall_setTimer() service
   1497           *   used to implement OSAL timer
   1498           *
   1499           * @param   arg  In this case, the timer sequence number is passed.
   1500           *
   1501           * @return  None
   1502           */
   1503          static void osal_msec_timer_cback(void *arg)
   1504          {
   1505            unsigned seq = (unsigned) arg;
   1506            halIntState_t intState;
   1507          
   1508            HAL_ENTER_CRITICAL_SECTION(intState);
   1509            if (seq == osal_msec_timer_seq)
   1510            {
   1511              ICall_signal(osal_semaphore);
   1512            }
   1513            HAL_EXIT_CRITICAL_SECTION(intState);
   1514          }
   1515          
   1516          /*********************************************************************
   1517           * @fn      osal_service_entry
   1518           *
   1519           * @brief
   1520           *
   1521           *   This function is service function for messaging service
   1522           *
   1523           * @param   args  arguments.
   1524           *
   1525           * @return  ICall error code
   1526           */
   1527          ICall_Errno osal_service_entry(ICall_FuncArgsHdr *args)
   1528          {
   1529            if (args->func == ICALL_MSG_FUNC_GET_LOCAL_MSG_ENTITY_ID)
   1530            {
   1531              /* Get proxy ID */
   1532              ((ICall_GetLocalMsgEntityIdArgs *)args)->localId =
   1533                osal_alien2proxy(((ICall_GetLocalMsgEntityIdArgs *)args)->entity);
   1534              if (((ICall_GetLocalMsgEntityIdArgs *)args)->localId == TASK_NO_TASK)
   1535              {
   1536                return ICALL_ERRNO_NO_RESOURCE;
   1537              }
   1538            }
   1539            else
   1540            {
   1541              return ICALL_ERRNO_INVALID_FUNCTION;
   1542            }
   1543            return ICALL_ERRNO_SUCCESS;
   1544          }
   1545          #endif /* USE_ICALL */
   1546          
   1547          /*********************************************************************
   1548           * @fn      osal_run_system
   1549           *
   1550           * @brief
   1551           *
   1552           *   This function will make one pass through the OSAL taskEvents table
   1553           *   and call the task_event_processor() function for the first task that
   1554           *   is found with at least one event pending. If there are no pending
   1555           *   events (all tasks), this function puts the processor into Sleep.
   1556           *
   1557           * @param   void
   1558           *
   1559           * @return  none
   1560           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1561          void osal_run_system( void )
   \                     osal_run_system:
   1562          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   1563            uint8 idx = 0;
   \   000005   75..00       MOV       ?V0,#0x0
   1564          
   1565          #ifdef USE_ICALL
   1566            uint32 next_timeout_prior = osal_next_timeout();
   1567          #else /* USE_ICALL */
   1568          #ifndef HAL_BOARD_CC2538
   1569            osalTimeUpdate();
   \   000008                ; Setup parameters for call to function osalTimeUpdate
   \   000008   12....       LCALL     `??osalTimeUpdate::?relay`; Banked call to: osalTimeUpdate
   1570          #endif
   1571          
   1572            Hal_ProcessPoll();
   \   00000B                ; Setup parameters for call to function Hal_ProcessPoll
   \   00000B   12....       LCALL     `??Hal_ProcessPoll::?relay`; Banked call to: Hal_ProcessPoll
   1573          #endif /* USE_ICALL */
   1574          
   1575          #ifdef USE_ICALL
   1576            {
   1577              /* Update osal timers to the latest before running any OSAL processes
   1578               * regardless of wakeup callback from ICall because OSAL timers are added
   1579               * relative to the current time. */
   1580              unsigned long newtimestamp = ICall_getTicks();
   1581              uint32 milliseconds;
   1582          
   1583              if (osal_tickperiod == 1000)
   1584              {
   1585                milliseconds = newtimestamp - osal_last_timestamp;
   1586                osal_last_timestamp = newtimestamp;
   1587              }
   1588              else
   1589              {
   1590                unsigned long long delta = (unsigned long long)
   1591                  ((newtimestamp - osal_last_timestamp) & 0xfffffffful);
   1592                delta *= osal_tickperiod;
   1593                delta /= 1000;
   1594                milliseconds = (uint32) delta;
   1595                osal_last_timestamp += (uint32) (delta * 1000 / osal_tickperiod);
   1596              }
   1597              osalAdjustTimer(milliseconds);
   1598              /* Set a value that will never match osal_next_timeout()
   1599               * return value so that the next time can be scheduled.
   1600               */
   1601              next_timeout_prior = 0xfffffffful;
   1602            }
   1603            if (osal_eventloop_hook)
   1604            {
   1605              osal_eventloop_hook();
   1606            }
   1607          
   1608            for (;;)
   1609            {
   1610              void *msg;
   1611              ICall_EntityID src, dst;
   1612              osal_msg_hdr_t *hdr;
   1613              uint8 dest_id;
   1614          
   1615              if (ICall_fetchMsg(&src, &dst, &msg) != ICALL_ERRNO_SUCCESS)
   1616              {
   1617                break;
   1618              }
   1619              hdr = (osal_msg_hdr_t *) msg - 1;
   1620              dest_id = osal_dispatch2id(dst);
   1621              if (dest_id == TASK_NO_TASK)
   1622              {
   1623                /* Something wrong */
   1624                ICall_abort();
   1625              }
   1626              else
   1627              {
   1628                /* Message towards one of the tasks */
   1629                /* Create a proxy task ID if necessary and
   1630                 * queue the message to the OSAL internal queue.
   1631                 */
   1632                uint8 proxyid = osal_alien2proxy(hdr->srcentity);
   1633          
   1634                if (hdr->format == ICALL_MSG_FORMAT_1ST_CHAR_TASK_ID)
   1635                {
   1636                  uint8 *bytes = msg;
   1637                  *bytes = proxyid;
   1638                }
   1639                else if (hdr->format == ICALL_MSG_FORMAT_3RD_CHAR_TASK_ID)
   1640                {
   1641                  uint8 *bytes = msg;
   1642                  bytes[2] = proxyid;
   1643                }
   1644                /* now queue the message to the OSAL queue */
   1645                osal_msg_send(dest_id, msg);
   1646              }
   1647            }
   1648          #endif /* USE_ICALL */
   1649          
   1650            do {
   1651              if (tasksEvents[idx])  // Task is highest priority that is ready.
   \                     ??osal_run_system_0:
   \   00000E   A8..         MOV       R0,?V0
   \   000010   E8           MOV       A,R0
   \   000011   28           ADD       A,R0
   \   000012   12....       LCALL     ?Subroutine17 & 0xFFFF
   1652              {
   1653                break;
   1654              }
   1655            } while (++idx < tasksCnt);
   \                     ??CrossCallReturnLabel_23:
   \   000015   12....       LCALL     ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_57:
   \   000018   700D         JNZ       ??osal_run_system_1
   \   00001A   05..         INC       ?V0
   \   00001C   90....       MOV       DPTR,#tasksCnt
   \   00001F   E0           MOVX      A,@DPTR
   \   000020   F8           MOV       R0,A
   \   000021   E5..         MOV       A,?V0
   \   000023   C3           CLR       C
   \   000024   98           SUBB      A,R0
   \   000025   40E7         JC        ??osal_run_system_0
   1656          
   1657            if (idx < tasksCnt)
   \                     ??osal_run_system_1:
   \   000027   90....       MOV       DPTR,#tasksCnt
   \   00002A   E0           MOVX      A,@DPTR
   \   00002B   F8           MOV       R0,A
   \   00002C   E5..         MOV       A,?V0
   \   00002E   C3           CLR       C
   \   00002F   98           SUBB      A,R0
   \   000030   5066         JNC       ??osal_run_system_2
   1658            {
   1659              uint16 events;
   1660              halIntState_t intState;
   1661          
   1662              HAL_ENTER_CRITICAL_SECTION(intState);
   \   000032   ACA8         MOV       R4,0xa8+0x0
   \   000034   C2AF         CLR       0xa8.7
   1663              events = tasksEvents[idx];
   \   000036   AE..         MOV       R6,?V0
   \   000038   EE           MOV       A,R6
   \   000039   2E           ADD       A,R6
   \   00003A   FE           MOV       R6,A
   \   00003B   E4           CLR       A
   \   00003C   33           RLC       A
   \   00003D   FF           MOV       R7,A
   \   00003E   90....       MOV       DPTR,#tasksEvents
   \   000041   E0           MOVX      A,@DPTR
   \   000042   2E           ADD       A,R6
   \   000043   F8           MOV       R0,A
   \   000044   A3           INC       DPTR
   \   000045   E0           MOVX      A,@DPTR
   \   000046   3F           ADDC      A,R7
   \   000047   F9           MOV       R1,A
   \   000048   8882         MOV       DPL,R0
   \   00004A   F583         MOV       DPH,A
   \   00004C   12....       LCALL     ??Subroutine32_0 & 0xFFFF
   1664              tasksEvents[idx] = 0;  // Clear the Events for this task.
   \                     ??CrossCallReturnLabel_62:
   \   00004F   8882         MOV       DPL,R0
   \   000051   8983         MOV       DPH,R1
   \   000053   E4           CLR       A
   \   000054   F0           MOVX      @DPTR,A
   \   000055   A3           INC       DPTR
   \   000056   F0           MOVX      @DPTR,A
   1665              HAL_EXIT_CRITICAL_SECTION(intState);
   \   000057   EC           MOV       A,R4
   \   000058   A2E7         MOV       C,0xE0 /* A   */.7
   \   00005A   92AF         MOV       0xa8.7,C
   1666          
   1667              activeTaskID = idx;
   \   00005C   E5..         MOV       A,?V0
   \   00005E   90....       MOV       DPTR,#activeTaskID
   \   000061   F0           MOVX      @DPTR,A
   1668              events = (tasksArr[idx])( idx, events );
   \   000062                ; Setup parameters for indirect call
   \   000062   F9           MOV       R1,A
   \   000063   74..         MOV       A,#tasksArr & 0xff
   \   000065   2E           ADD       A,R6
   \   000066   F582         MOV       DPL,A
   \   000068   74..         MOV       A,#(tasksArr >> 8) & 0xff
   \   00006A   3F           ADDC      A,R7
   \   00006B   F583         MOV       DPH,A
   \   00006D   12....       LCALL     ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_19:
   \   000070   12....       LCALL     ?CALL_IND
   1669              activeTaskID = TASK_NO_TASK;
   \   000073   90....       MOV       DPTR,#activeTaskID
   \   000076   74FF         MOV       A,#-0x1
   \   000078   F0           MOVX      @DPTR,A
   1670          
   1671              HAL_ENTER_CRITICAL_SECTION(intState);
   \   000079   A8A8         MOV       R0,0xa8+0x0
   \   00007B   C2AF         CLR       0xa8.7
   1672              tasksEvents[idx] |= events;  // Add back unprocessed events to the current task.
   \   00007D   90....       MOV       DPTR,#tasksEvents
   \   000080   E0           MOVX      A,@DPTR
   \   000081   2E           ADD       A,R6
   \   000082   F9           MOV       R1,A
   \   000083   A3           INC       DPTR
   \   000084   E0           MOVX      A,@DPTR
   \   000085   3F           ADDC      A,R7
   \   000086   8982         MOV       DPL,R1
   \   000088   F583         MOV       DPH,A
   \   00008A   E0           MOVX      A,@DPTR
   \   00008B   4A           ORL       A,R2
   \   00008C   F0           MOVX      @DPTR,A
   \   00008D   A3           INC       DPTR
   \   00008E   E0           MOVX      A,@DPTR
   \   00008F   4B           ORL       A,R3
   \   000090   F0           MOVX      @DPTR,A
   1673              HAL_EXIT_CRITICAL_SECTION(intState);
   \   000091   E8           MOV       A,R0
   \   000092   A2E7         MOV       C,0xE0 /* A   */.7
   \   000094   92AF         MOV       0xa8.7,C
   \   000096   8003         SJMP      ??osal_run_system_3
   1674            }
   1675          #if defined( POWER_SAVING ) && !defined(USE_ICALL)
   1676            else  // Complete pass through all task events with no activity?
   1677            {
   1678              osal_pwrmgr_powerconserve();  // Put the processor/system into sleep
   \                     ??osal_run_system_2:
   \   000098                ; Setup parameters for call to function osal_pwrmgr_powerconserve
   \   000098   12....       LCALL     `??osal_pwrmgr_powerconserve::?relay`; Banked call to: osal_pwrmgr_powerconserve
   1679            }
   1680          #endif
   1681          
   1682            /* Yield in case cooperative scheduling is being used. */
   1683          #if defined (configUSE_PREEMPTION) && (configUSE_PREEMPTION == 0)
   1684            {
   1685              osal_task_yield();
   1686            }
   1687          #endif
   1688          
   1689          #if defined USE_ICALL
   1690            /* Note that scheduling wakeup at this point instead of
   1691             * scheduling it upon ever OSAL start timer request,
   1692             * would only work if OSAL start timer call is made
   1693             * from OSAL tasks, but not from either ISR or
   1694             * non-OSAL application thread.
   1695             * In case, OSAL start timer is called from non-OSAL
   1696             * task, the scheduling should be part of OSAL_Timers
   1697             * module.
   1698             * Such a change to OSAL_Timers module was not made
   1699             * in order not to diverge the OSAL implementations
   1700             * too drastically between pure OSAL solution vs.
   1701             * OSAL upon service dispatcher (RTOS).
   1702             * TODO: reconsider the above statement.
   1703             */
   1704            {
   1705              halIntState_t intState;
   1706          
   1707              uint32 next_timeout_post = osal_next_timeout();
   1708              if (next_timeout_post != next_timeout_prior)
   1709              {
   1710                /* Next wakeup time has to be scheduled */
   1711                if (next_timeout_post == 0)
   1712                {
   1713                  /* No timer. Set time to the max */
   1714                  next_timeout_post = OSAL_TIMERS_MAX_TIMEOUT;
   1715                }
   1716                if (next_timeout_post > osal_max_msecs)
   1717                {
   1718                  next_timeout_post = osal_max_msecs;
   1719                }
   1720                /* Restart timer */
   1721                HAL_ENTER_CRITICAL_SECTION(intState);
   1722                ICall_stopTimer(osal_timerid_msec_timer);
   1723                ICall_setTimerMSecs(next_timeout_post, osal_msec_timer_cback,
   1724                                    (void *) (++osal_msec_timer_seq),
   1725                                    &osal_timerid_msec_timer);
   1726                HAL_EXIT_CRITICAL_SECTION(intState);
   1727              }
   1728            }
   1729          #endif /* USE_ICALL */
   1730          }
   \                     ??osal_run_system_3:
   \   00009B   02....       LJMP      ?Subroutine2 & 0xFFFF
   \   00009E                REQUIRE _A_IEN0
   1731          
   1732          /*********************************************************************
   1733           * @fn      osal_buffer_uint32
   1734           *
   1735           * @brief
   1736           *
   1737           *   Buffer an uint32 value - LSB first.
   1738           *
   1739           * @param   buf - buffer
   1740           * @param   val - uint32 value
   1741           *
   1742           * @return  pointer to end of destination buffer
   1743           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1744          uint8* osal_buffer_uint32( uint8 *buf, uint32 val )
   \                     osal_buffer_uint32:
   1745          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV       A,#-0x10
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   7410         MOV       A,#0x10
   \   000007   12....       LCALL     ?XSTACK_DISP0_8
   \   00000A   78..         MOV       R0,#?V4
   \   00000C   12....       LCALL     ?L_MOV_X
   1746            *buf++ = BREAK_UINT32( val, 0 );
   \   00000F   8A82         MOV       DPL,R2
   \   000011   8B83         MOV       DPH,R3
   \   000013   E5..         MOV       A,?V4
   \   000015   12....       LCALL     ?Subroutine22 & 0xFFFF
   1747            *buf++ = BREAK_UINT32( val, 1 );
   1748            *buf++ = BREAK_UINT32( val, 2 );
   \                     ??CrossCallReturnLabel_28:
   \   000018   85....       MOV       ?V0,?V4
   \   00001B   85....       MOV       ?V2,?V6
   \   00001E   85....       MOV       ?V3,?V7
   \   000021   7410         MOV       A,#0x10
   \   000023   78..         MOV       R0,#?V0
   \   000025   12....       LCALL     ?UL_SHR
   \   000028   8A82         MOV       DPL,R2
   \   00002A   8B83         MOV       DPH,R3
   \   00002C   A3           INC       DPTR
   \   00002D   A3           INC       DPTR
   \   00002E   E5..         MOV       A,?V0
   \   000030   F0           MOVX      @DPTR,A
   1749            *buf++ = BREAK_UINT32( val, 3 );
   \   000031   7418         MOV       A,#0x18
   \   000033   78..         MOV       R0,#?V4
   \   000035   12....       LCALL     ?UL_SHR
   \   000038   8A82         MOV       DPL,R2
   \   00003A   8B83         MOV       DPH,R3
   \   00003C   A3           INC       DPTR
   \   00003D   A3           INC       DPTR
   \   00003E   A3           INC       DPTR
   \   00003F   E5..         MOV       A,?V4
   \   000041   F0           MOVX      @DPTR,A
   1750          
   1751            return buf;
   \   000042   EA           MOV       A,R2
   \   000043   2404         ADD       A,#0x4
   \   000045   FA           MOV       R2,A
   \   000046   5001         JNC       ??osal_buffer_uint32_0
   \   000048   0B           INC       R3
   \                     ??osal_buffer_uint32_0:
   \   000049   02....       LJMP      ?Subroutine3 & 0xFFFF
   1752          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine22:
   \   000000   F0           MOVX      @DPTR,A
   \   000001   85....       MOV       ?V1,?V5
   \   000004   E5..         MOV       A,?V1
   \   000006   A3           INC       DPTR
   \   000007   F0           MOVX      @DPTR,A
   \   000008   22           RET
   1753          
   1754          /*********************************************************************
   1755           * @fn      osal_buffer_uint24
   1756           *
   1757           * @brief
   1758           *
   1759           *   Buffer an uint24 value - LSB first. Note that type uint24 is
   1760           *   typedef to uint32 in comdef.h
   1761           *
   1762           * @param   buf - buffer
   1763           * @param   val - uint24 value
   1764           *
   1765           * @return  pointer to end of destination buffer
   1766           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1767          uint8* osal_buffer_uint24( uint8 *buf, uint24 val )
   \                     osal_buffer_uint24:
   1768          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV       A,#-0x10
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   7410         MOV       A,#0x10
   \   000007   12....       LCALL     ?XSTACK_DISP0_8
   \   00000A   78..         MOV       R0,#?V4
   \   00000C   12....       LCALL     ?L_MOV_X
   1769            *buf++ = BREAK_UINT32( val, 0 );
   \   00000F   85....       MOV       ?V0,?V4
   \   000012   8A82         MOV       DPL,R2
   \   000014   8B83         MOV       DPH,R3
   \   000016   E5..         MOV       A,?V0
   \   000018   12....       LCALL     ?Subroutine22 & 0xFFFF
   1770            *buf++ = BREAK_UINT32( val, 1 );
   1771            *buf++ = BREAK_UINT32( val, 2 );
   \                     ??CrossCallReturnLabel_29:
   \   00001B   7410         MOV       A,#0x10
   \   00001D   78..         MOV       R0,#?V4
   \   00001F   12....       LCALL     ?UL_SHR
   \   000022   8A82         MOV       DPL,R2
   \   000024   8B83         MOV       DPH,R3
   \   000026   A3           INC       DPTR
   \   000027   A3           INC       DPTR
   \   000028   E5..         MOV       A,?V4
   \   00002A   F0           MOVX      @DPTR,A
   1772          
   1773            return buf;
   \   00002B   EA           MOV       A,R2
   \   00002C   2403         ADD       A,#0x3
   \   00002E   FA           MOV       R2,A
   \   00002F   5001         JNC       ??osal_buffer_uint24_0
   \   000031   0B           INC       R3
   \                     ??osal_buffer_uint24_0:
   \   000032   02....       LJMP      ?Subroutine3 & 0xFFFF
   1774          }
   1775          
   1776          /*********************************************************************
   1777           * @fn      osal_isbufset
   1778           *
   1779           * @brief
   1780           *
   1781           *   Is all of the array elements set to a value?
   1782           *
   1783           * @param   buf - buffer to check
   1784           * @param   val - value to check each array element for
   1785           * @param   len - length to check
   1786           *
   1787           * @return  TRUE if all "val"
   1788           *          FALSE otherwise
   1789           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1790          uint8 osal_isbufset( uint8 *buf, uint8 val, uint8 len )
   \                     osal_isbufset:
   1791          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV       A,R1
   \   000006   FD           MOV       R5,A
   1792            uint8 x;
   1793          
   1794            if ( buf == NULL )
   \   000007   EA           MOV       A,R2
   \   000008   4B           ORL       A,R3
   \   000009   6018         JZ        ??osal_isbufset_0
   1795            {
   1796              return ( FALSE );
   1797            }
   1798          
   1799            for ( x = 0; x < len; x++ )
   \   00000B   7800         MOV       R0,#0x0
   \   00000D   8001         SJMP      ??osal_isbufset_1
   \                     ??osal_isbufset_2:
   \   00000F   08           INC       R0
   \                     ??osal_isbufset_1:
   \   000010   E8           MOV       A,R0
   \   000011   C3           CLR       C
   \   000012   9C           SUBB      A,R4
   \   000013   5012         JNC       ??osal_isbufset_3
   1800            {
   1801              // Check for non-initialized value
   1802              if ( buf[x] != val )
   \   000015   E8           MOV       A,R0
   \   000016   FE           MOV       R6,A
   \   000017   EA           MOV       A,R2
   \   000018   2E           ADD       A,R6
   \   000019   F582         MOV       DPL,A
   \   00001B   E4           CLR       A
   \   00001C   3B           ADDC      A,R3
   \   00001D   F583         MOV       DPH,A
   \   00001F   E0           MOVX      A,@DPTR
   \   000020   6D           XRL       A,R5
   \   000021   60EC         JZ        ??osal_isbufset_2
   1803              {
   1804                return ( FALSE );
   \                     ??osal_isbufset_0:
   \   000023   7900         MOV       R1,#0x0
   \   000025   8002         SJMP      ??osal_isbufset_4
   1805              }
   1806            }
   1807            return ( TRUE );
   \                     ??osal_isbufset_3:
   \   000027   7901         MOV       R1,#0x1
   \                     ??osal_isbufset_4:
   \   000029   02....       LJMP      ??Subroutine27_0 & 0xFFFF
   1808          }
   1809          
   1810          /*********************************************************************
   1811           * @fn      osal_self
   1812           *
   1813           * @brief
   1814           *
   1815           *   This function returns the task ID of the current (active) task.
   1816           *
   1817           * @param   void
   1818           *
   1819           * @return   active task ID or TASK_NO_TASK if no task is active
   1820           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1821          uint8 osal_self( void )
   \                     osal_self:
   1822          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1823            return ( activeTaskID );
   \   000004   90....       MOV       DPTR,#activeTaskID
   \   000007   E0           MOVX      A,@DPTR
   \   000008   F9           MOV       R1,A
   \   000009   02....       LJMP      ?Subroutine0 & 0xFFFF
   1824          }

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for activeTaskID>`:
   \   000000   FF           DB 255

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "">`:
   \   000000   00           DB ""
   \   000001   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \   000009   00           DB 0

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "">_1`:
   \   000000   00           DB ""
   \   000001   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \   000009   00           DB 0

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "">_2`:
   \   000000   00           DB ""
   \   000001   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \   000009   00           DB 0

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "0">`:
   \   000000   3000         DB "0"

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_2710:
   \   000000   10270000     DD 10000

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_5f5e100:
   \   000000   00E1F505     DD 100000000
   1825          
   1826          /*********************************************************************
   1827           */

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      1     59   _ltoa
        0     57   -> _itoa
        0     57   -> strcat
        0     57   -> strcpy
        0     57   -> strlen
      1     20   osal_buffer_uint24
      1     20   osal_buffer_uint32
      2      0   osal_build_uint16
      0     16   osal_build_uint32
      0     23   osal_clear_event
      2      0   osal_init_system
        2      0   -> osalInitTasks
        2      0   -> osalTimerInit
        2      0   -> osal_mem_init
        2      0   -> osal_mem_kick
        2      0   -> osal_pwrmgr_init
      0      0   osal_int_disable
      0      0   osal_int_enable
      0      9   osal_isbufset
      0      0   osal_isr_register
      0     22   osal_memcmp
      1     27   osal_memcpy
      0     18   osal_memdup
        0     15   -> osal_mem_alloc
        0     18   -> osal_memcpy
      0     12   osal_memset
        0     12   -> memset
      0     10   osal_msg_allocate
        0     10   -> osal_mem_alloc
      0      9   osal_msg_count
      2      9   osal_msg_deallocate
        2      0   -> osal_mem_free
      0     10   osal_msg_dequeue
      0     18   osal_msg_enqueue
      0     10   osal_msg_enqueue_max
      1     18   osal_msg_enqueue_push
        0      9   -> osal_msg_deallocate
        0      9   -> osal_msg_enqueue
        0      9   -> osal_msg_push
        0      9   -> osal_set_event
      0     27   osal_msg_extract
      2      0   osal_msg_find
      0     18   osal_msg_push
      0      9   osal_msg_push_front
        0      9   -> osal_msg_enqueue_push
      0     16   osal_msg_receive
        0     14   -> osal_clear_event
        0     16   -> osal_msg_extract
        0     14   -> osal_set_event
      0      9   osal_msg_send
        0      9   -> osal_msg_enqueue_push
      2      0   osal_rand
        2      0   -> Onboard_rand
      1     12   osal_revmemcpy
      0     10   osal_run_system
        0     10   -> Hal_ProcessPoll
        0     10   -> osalTimeUpdate
        0     10   -> osal_pwrmgr_powerconserve
      2      0   osal_self
      0     23   osal_set_event
      2      0   osal_start_system
        2      0   -> osal_run_system
      2      0   osal_strlen
        2      0   -> strlen


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      10  ?<Constant "">
      10  ?<Constant "">_1
      10  ?<Constant "">_2
       2  ?<Constant "0">
       1  ?<Initializer for activeTaskID>
       4  ??Subroutine26_0
       5  ??Subroutine27_0
       6  ??Subroutine28_0
       3  ??Subroutine29_0
       5  ??Subroutine30_0
       8  ??Subroutine31_0
       6  ??Subroutine32_0
       7  ?Subroutine0
       4  ?Subroutine1
       6  ?Subroutine10
       8  ?Subroutine11
      12  ?Subroutine12
       3  ?Subroutine13
       8  ?Subroutine14
       9  ?Subroutine15
      15  ?Subroutine16
      16  ?Subroutine17
      13  ?Subroutine18
       3  ?Subroutine19
       5  ?Subroutine2
       4  ?Subroutine20
      15  ?Subroutine21
       9  ?Subroutine22
       8  ?Subroutine23
      14  ?Subroutine24
       9  ?Subroutine25
       5  ?Subroutine3
       2  ?Subroutine4
       6  ?Subroutine5
      24  ?Subroutine6
       2  ?Subroutine7
       6  ?Subroutine8
       8  ?Subroutine9
       1  WDCTL
       1  _A_IEN0
       4  __Constant_2710
       4  __Constant_5f5e100
     572  _ltoa
       1  activeTaskID
      53  osal_buffer_uint24
      76  osal_buffer_uint32
      25  osal_build_uint16
     122  osal_build_uint32
      53  osal_clear_event
      31  osal_init_system
      18  osal_int_disable
      18  osal_int_enable
      44  osal_isbufset
       5  osal_isr_register
     105  osal_memcmp
      43  osal_memcpy
      56  osal_memdup
      29  osal_memset
      69  osal_msg_allocate
      58  osal_msg_count
      34  osal_msg_deallocate
      80  osal_msg_dequeue
      52  osal_msg_enqueue
      77  osal_msg_enqueue_max
     100  osal_msg_enqueue_push
     108  osal_msg_extract
      63  osal_msg_find
      35  osal_msg_push
       9  osal_msg_push_front
     139  osal_msg_receive
       7  osal_msg_send
       2  osal_qHead
       9  osal_rand
      58  osal_revmemcpy
     158  osal_run_system
      12  osal_self
      59  osal_set_event
      25  osal_start_system
      10  osal_strlen
     210  -- Other

 
 2 670 bytes in segment BANKED_CODE
   210 bytes in segment BANK_RELAYS
     2 bytes in segment SFR_AN
     1 byte  in segment XDATA_I
     1 byte  in segment XDATA_ID
    40 bytes in segment XDATA_ROM_C
     2 bytes in segment XDATA_Z
 
   211 bytes of CODE     memory
    32 bytes of CONST    memory (+ 8 bytes shared)
     0 bytes of DATA     memory (+ 2 bytes shared)
 2 670 bytes of HUGECODE memory
     3 bytes of XDATA    memory

Errors: none
Warnings: none
